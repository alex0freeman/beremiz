/* File generated by Beremiz (PlugGenerate_C method of Modbus plugin) */

/*
 * Copyright (c) 2016 Mario de Sousa (msousa@fe.up.pt)
 *
 * This file is part of the Modbus library for Beremiz and matiec.
 *
 * This Modbus library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
 * General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this Modbus library.  If not, see <http://www.gnu.org/licenses/>.
 *
 * This code is made available on the understanding that it will not be
 * used in safety-critical situations without a full and competent review.
 */


#include <stdio.h>
#include <string.h>  /* required for memcpy() */
#include "mb_slave_and_master.h"
#include "MB_%(locstr)s.h"


#include <pthread.h>


#define MAX_MODBUS_ERROR_CODE 11
static const char *modbus_error_messages[MAX_MODBUS_ERROR_CODE+1] = {
    /* 0 */ "",                             /* un-used -> no error! */
    /* 1 */ "illegal/unsupported function",
    /* 2 */ "illegal data address",
    /* 3 */ "illegal data value",
    /* 4 */ "slave device failure",
    /* 5 */ "acknowledge -> slave intends to reply later",
    /* 6 */ "slave device busy",
    /* 7 */ "negative acknowledge",
    /* 8 */ "memory parity error",
    /* 9 */ "",                             /* undefined by Modbus */
    /* 10*/ "gateway path unavailable",
    /* 11*/ "gateway target device failed to respond"
};

#define BIT_IN_WORD 16

/* unpack analog registr  */
static inline void  __get_analog(client_request_t *raw_data, float  *packed_data) {
u8    bit_processed ;
u16  raw_d;
float ttt, analog_data, scale, offset;

    raw_d = raw_data->plcv_buffer[0];
    scale = raw_data->scale;
    offset = raw_data->offset;
    if(scale > 0 ){
        analog_data = raw_d / scale + offset;
    }
    else {
        analog_data = (float) raw_d;
    }

    fprintf(stderr, "registr raw_data %%d  \n", raw_d);
    fprintf(stderr, "scale %%.3f \n", scale);
    fprintf(stderr, "offset %%.3f \n", offset);
    fprintf(stderr, "unpacked analog data %%.3f \n", analog_data);

    *packed_data =  analog_data;
}

/* unpack analog registr  */
static inline void  __pack_analog(client_request_t *raw_data, float  *packed_data) {
u8    bit_processed ;
u16  pack_data;
float  analog_data, scale, offset;

    analog_data = raw_data->analog_buffer[0];
    scale = raw_data->scale;
    offset = raw_data->offset;
    if(scale > 0 ){
        pack_data = (analog_data - offset)  * scale;
    }
    else {
        pack_data = analog_data;
    }
//
//    fprintf(stderr, "registr raw_data %%d  \n", raw_d);
//    fprintf(stderr, "scale %%.3f \n", scale);
//    fprintf(stderr, "offset %%.3f \n", offset);
//    fprintf(stderr, "unpacked analog data %%.3f \n", analog_data);

    raw_data->plcv_buffer[0] = (u16) pack_data;
}

/* pack bits from unpacked_data to packed_data */
static inline void  __pack_bits(request_registers_t *unpacked_data, u16  *packed_data) {
  u8    bit_processed ;
  u16 temp, byte;

  for(bit_processed = 0; bit_processed < BIT_IN_WORD; bit_processed++)  {
     temp = *packed_data;
      if(unpacked_data->num_bit[bit_processed]){
       temp |=  (1 << bit_processed); /*   set bit */
      }
      else{
        temp &= ~(1 << bit_processed); /* reset bit */
      }
      //fprintf(stderr, "Check paking bit  %%d ---\n", unpacked_data->num_bit[bit_processed]);
      *packed_data =  temp;
    }
}

/* unpack bits from packed_data to unpacked_data */
static inline void  __unpack_bits(request_registers_t *unpacked_data, u16  *packed_data){
  u8    bit_processed ;
  u16 temp, byte;

  for(bit_processed = 0; bit_processed < BIT_IN_WORD; bit_processed++)
  {
    temp = *packed_data;

    unpacked_data->num_bit[bit_processed] = (temp  >> bit_processed) & 1;
    //fprintf(stderr, "Check unpacking bit %%d ---\n", unpacked_data->num_bit[bit_processed]);
     *packed_data =  temp;
  }
}

/* Execute a modbus client transaction/request */
static int __execute_mb_request_in(int request_id){

   // __pack_bits(&request_registers[request_id] ,  &client_requests[request_id].plcv_buffer[0]);


	switch (client_requests[request_id].mb_function){

	case  1: break;
	case  2: break;

	case  3: /* read holding registers */
		return read_output_words(client_requests[request_id].slave_id,
								client_requests[request_id].address,
								client_requests[request_id].count,
								client_requests[request_id].coms_buffer,
								(int) client_requests[request_id].count,

								client_nodes[client_requests[request_id].client_node_id].mb_nd,
								client_requests[request_id].retries,
								&(client_requests[request_id].error_code),
								&(client_requests[request_id].resp_timeout),
								&(client_requests[request_id].coms_buf_mutex));

	case  4: break;
	case  5: break;

	case  6: /* write single register */
		return write_output_word(client_requests[request_id].slave_id,
								client_requests[request_id].address,
								client_requests[request_id].coms_buffer[0],

								client_nodes[client_requests[request_id].client_node_id].mb_nd,
								client_requests[request_id].retries,
								&(client_requests[request_id].error_code),
								&(client_requests[request_id].resp_timeout),
								&(client_requests[request_id].coms_buf_mutex));

	case  7: break; /* function not yet supported */
	case  8: break; /* function not yet supported */
	case  9: break; /* function not yet supported */
	case 10: break; /* function not yet supported */
	case 11: break; /* function not yet supported */
	case 12: break; /* function not yet supported */
	case 13: break; /* function not yet supported */
	case 14: break; /* function not yet supported */

	case 15: break;

	case 16: /* write multiple registers */
		return write_output_words(client_requests[request_id].slave_id,
								client_requests[request_id].address,
								client_requests[request_id].count,
								client_requests[request_id].coms_buffer,

								client_nodes[client_requests[request_id].client_node_id].mb_nd,
								client_requests[request_id].retries,
								&(client_requests[request_id].error_code),
								&(client_requests[request_id].resp_timeout),
								&(client_requests[request_id].coms_buf_mutex));

	default: break;  /* should never occur, if file generation is correct */
	}




	fprintf(stderr, "Modbus plugin: Modbus function %%d not supported\n", request_id); /* should never occur, if file generation is correct */
	return -1;
}

static void __print_structure(request_registers_t *unpacked_data, int request_id ){
u8    bit_processed, allbits;
    for(bit_processed = 0; bit_processed < BIT_IN_WORD; bit_processed++)
  {
    fprintf(stderr, "bits in structure %%d ---\n", unpacked_data->num_bit[bit_processed]);
  }
 //fprintf(stderr, "--2 bits  structure %%d in request %%d  ---\n", unpacked_data->num_bit[1], request_id);

}

static int __execute_mb_request(int request_id){
int ret = 0;
    fprintf(stderr, "#_____________________________# \n" );
    //fprintf(stderr, "request id %%d  \n", request_id);
    fprintf(stderr, "request address %%d  \n", client_requests[request_id].address);
    fprintf(stderr, "request buffer %%d  \n", client_requests[request_id].plcv_buffer[0]);

     if(client_requests[request_id].mb_function == 16){
        __pack_bits(&request_registers[request_id] ,  &client_requests[request_id].plcv_buffer[0]);
    }

    ret = __execute_mb_request_in(request_id);
    // unpack analogs
    __get_analog(&client_requests[request_id],  &client_requests[request_id].analog_buffer[0]);

    // получаем биты - сигналы
    if(client_requests[request_id].mb_function == 3)
    {
        __unpack_bits(&request_registers[request_id] ,  &client_requests[request_id].plcv_buffer[0]);
    }

   // __print_structure(&request_registers[request_id], request_id);

    fprintf(stderr, "#_____________________________# \n" );

	 return ret;
}





#define timespec_add(ts, sec, nsec) {		\
	ts.tv_sec  +=  sec;			\
	ts.tv_nsec += nsec;			\
	if (ts.tv_nsec >= 1000000000) {		\
		ts.tv_sec  ++;			\
		ts.tv_nsec -= 1000000000;	\
	}					\
}


static void *__mb_client_thread(void *_index)  {


	// humour the compiler.
	return NULL;
}


int __cleanup_%(locstr)s ();
int __init_%(locstr)s (int argc, char **argv){




	return 0;

error_exit:
	__cleanup_%(locstr)s ();
	return -1;
}





void __publish_%(locstr)s (){
	int index;

//	for (index=0; index < NUMBER_OF_CLIENT_REQTS; index ++){
//		/*just do the output requests */
//		if (client_requests[index].req_type == req_output){
//			if(pthread_mutex_trylock(&(client_requests[index].coms_buf_mutex)) == 0){
//                // copy from plcv_buffer to coms_buffer
//                memcpy((void *)client_requests[index].coms_buffer /* destination */,
//                       (void *)client_requests[index].plcv_buffer /* source */,
//                       REQ_BUF_SIZE * sizeof(u16) /* size in bytes */);
//                pthread_mutex_unlock(&(client_requests[index].coms_buf_mutex));
//            }
//		}
//	}
}


void __retrieve_%(locstr)s (){
	int index;

//	for (index=0; index < NUMBER_OF_CLIENT_REQTS; index ++){
//		/*just do the input requests */
//		if (client_requests[index].req_type == req_input){
//			if(pthread_mutex_trylock(&(client_requests[index].coms_buf_mutex)) == 0){
//                // copy from coms_buffer to plcv_buffer
//                memcpy((void *)client_requests[index].plcv_buffer /* destination */,
//                       (void *)client_requests[index].coms_buffer /* source */,
//                       REQ_BUF_SIZE * sizeof(u16) /* size in bytes */);
//                pthread_mutex_unlock(&(client_requests[index].coms_buf_mutex));
//            }
//		}
//	}

}


int __cleanup_%(locstr)s (){
	int index, close;
	int res = 0;
//
//	/* kill thread and close connections of each modbus client node */
//	for (index=0; index < NUMBER_OF_CLIENT_NODES; index++) {
//		close = 0;
//		if (client_nodes[index].init_state >= 2) {
//			// thread was launched, so we try to cancel it!
//			close  = pthread_cancel(client_nodes[index].thread_id);
//			close |= pthread_join  (client_nodes[index].thread_id, NULL);
//			if (close < 0)
//				fprintf(stderr, "Modbus plugin: Error closing thread for modbus client %%s\n", client_nodes[index].location);
//		}
//		res |= close;
//
//		close = 0;
//		if (client_nodes[index].init_state >= 1) {
//			// modbus client node was created, so we try to close it!
//			close = mb_master_close (client_nodes[index].mb_nd);
//			if (close < 0){
//				fprintf(stderr, "Modbus plugin: Error closing modbus client node %%s\n", client_nodes[index].location);
//				// We try to shut down as much as possible, so we do not return noW!
//			}
//			client_nodes[index].mb_nd = -1;
//		}
//		res |= close;
//		client_nodes[index].init_state = 0;
//	}
//
//	/* destroy the mutex of each client request */
//	for (index=0; index < NUMBER_OF_CLIENT_REQTS; index ++) {
//		if (pthread_mutex_destroy(&(client_requests[index].coms_buf_mutex))) {
//			fprintf(stderr, "Modbus plugin: Error destroying request for modbus client node %%s\n", client_nodes[client_requests[index].client_node_id].location);
//			// We try to shut down as much as possible, so we do not return noW!
//			res |= -1;
//		}
//	}
//
//	/* modbus library close */
//	//fprintf(stderr, "Shutting down modbus library...\n");
//	if (mb_slave_and_master_done()<0) {
//		fprintf(stderr, "Modbus plugin: Error shutting down modbus library\n");
//		res |= -1;
//	}

	return res;
}