% Generated by Sphinx.
\def\sphinxdocclass{report}
\newif\ifsphinxKeepOldNames \sphinxKeepOldNamestrue
\documentclass[letterpaper,10pt,russian]{sphinxmanual}
\usepackage{iftex}

\ifPDFTeX
  \usepackage[utf8]{inputenc}
\fi
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}

\usepackage[Sonny]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}

\addto\captionsrussian{\renewcommand{\contentsname}{Содержание}}

\addto\captionsrussian{\renewcommand{\figurename}{Рисунок }}
\makeatletter
\def\fnum@figure{\figurename\thefigure }
\makeatother
\addto\captionsrussian{\renewcommand{\tablename}{Таблица }}
\SetupFloatingEnvironment{literal-block}{name=Листинг }

\addto\extrasrussian{\def\pageautorefname{page}}

\setcounter{tocdepth}{2}
% Centering for images
\makeatletter
\g@addto@macro\@floatboxreset\centering
\makeatother

% Fonts
\usepackage{fontspec}
\setmainfont{cmun}[
Extension=.otf,
UprightFont=*rm,
ItalicFont=*ti,
BoldFont=*bx,
BoldItalicFont=*bi,
]
\setsansfont{cmun}[
Extension=.otf,
UprightFont=*ss,
ItalicFont=*si,
BoldFont=*sx,
BoldItalicFont=*so,
]
\setmonofont{cmun}[
Extension=.otf,
UprightFont=*btl,
ItalicFont=*bto,
BoldFont=*tb,
BoldItalicFont=*tx,
]
\usepackage{xltxtra}
\usepackage{xecyr}

% Show pages number
\usepackage{lastpage}

% Custom packages
\usepackage{custom}


\title{Beremiz Documentation}
\date{янв. 14, 2019}
\release{}
\author{Beremiz Documentation Authors}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Выпуск}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vm\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@dl\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@fm\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sa\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}
\begin{notice}{note}{Примечание:}
Документация находится в стадии разработки.

Устаревшая pdf-версия данного руководства \href{http://www.sm1820.com.ru/files/beremiz/beremiz\_manual.pdf}{доступна} на сайте ИНЭУМ.
\end{notice}



В данном руководстве представлено описание порядка работы со средой разработки «Beremiz». Документ содержит информацию о назначении программы, условиях выполнения, элементах пользовательского интерфейса, порядке разработки прикладных программ, работе с внешними модулями – плагинами. Рассмотрены основные её компоненты и их назначение с приведёнными примерами. Описан процесс работы с редакторами языков стандарта IEC 61131-3 и режимом отладки созданных прикладных программ. В документе приведены тексты сообщений, выдаваемых в ходе выполнения программы и описание их содержания.

В приложениях приведены порядок установки среды «Beremiz» под операционные системы Windows и Linux, описание стандартных функциональных блоков доступных для оператора и общие сведения о языках стандарта IEC 61131-3.


\chapter{Назначение и условия применения программы}
\label{index:beremiz}\label{index:id2}
Среда разработки «Beremiz» предназначена для создания и отладки
прикладных программ на языках стандарта IEC 61131-3 для целевых
устройств (программируемых логических контроллеров) на базе СМ1820М. В
качестве языков описания алгоритмов и логики работы данных программ,
могут выступать как текстовые Structured Text (далее ST) и Instruction
List (далее IL), так и графические Function Block Diagram (далее FBD),
Ladder Diagram (далее LD), Sequential Function Chart (далее SFC).


\chapter{Характеристики программы}
\label{index:id3}
Среда разработки «Beremiz» может выполняться на операционных системах
Windows и Linux. Она написана с использованием кроссплатформенных языков
Python, C, C++ и дополнительных библиотек к ним. Поэтому для запуска и
работы «Beremiz», необходима сборка интерпретатора Python с определённым
набором установленных пакетов (библиотек).


\section{Инструкции по установке}
\label{install_guide/index::doc}\label{install_guide/index:id1}

\subsection{Установка среды разработки «Beremiz» под операционную систему Windows 7}
\label{install_guide/install_windows7:beremiz-windows-7}\label{install_guide/install_windows7::doc}
Для нормальной работы «Beremiz» под операционной системой Windows
необходимо наличие следующих программных средств:
\begin{itemize}
\item {} 
интерпретатор Python версии 2.7 со всеми необходимыми библиотеками
(wxPython-2.8, twisted, simplejson, Pyro, numpy, nevow);

\item {} 
UNIX-подобная среда Cygwin c интерфейсом командной строки для Windows
и установленным кросскомпиляторам для целевой архитектуры x86.

\end{itemize}

Интерпретатор языка Python и UNIX-подобная среда Cygwin находятся в
папке BeremizProject на DVD диске. Для установки необходимо:
\begin{enumerate}
\item {} 
скопировать папку BeremizProject в удобное для Вас место на жестком
диске;

\item {} 
перенести папку python из BeremizProject, например, на диск C;

\item {} 
добавить путь к перенесённой папке python в «Переменных среды»

\end{enumerate}

Добавление интерпретатора Python в переменные среды

Добавление интерпретатора языка Python осуществляется с помощью настроек
операционной системы. Необходимо перейти в «Панель управления» и выбрать
раздел «Система» (см. рис. 1.1).

\sphinxincludegraphics[width=4.86875in,height=3.36944in]{{image324}.png}

Рис. 1.1 – Панель управления в Windows 7. Раздел «Система и
безопасность»

Далее выбирается пункт «Дополнительные параметры системы» в меню слева
(см. рис. 1.2):

\sphinxincludegraphics[width=1.64028in,height=2.58194in]{{image325}.png}

Рис. 1.2 – Боковая панель диалога «Система» в Windows 7

Появится диалог «Свойства системы», в котором следует выбрать вкладку
«Дополнительно» и нажать «Переменные среды…» (см. рис. 1.3).

\sphinxincludegraphics[width=3.67708in,height=4.42708in]{{image326}.png}

Рис. 1.3 – Диалог «Свойства системы» в Windows 7

Необходимо найти в разделе «Системные переменные» переменную «Path» (см.
рис. 1.4) и нажать кнопку «Изменить».

\sphinxincludegraphics[width=3.42708in,height=3.79167in]{{image327}.png}

Рис. 1.4 – Диалог «Переменные среды» в Windows 7

В появившемся диалоге в поле «Значение переменной» добавляем, например,
в середину строки, строку «C:\textbackslash{}Python» (см. рис 1.5).

\sphinxincludegraphics[width=3.34722in,height=1.38681in]{{image328}.png}

Рис. 1.5 – Диалог изменения системной переменной под операционной
системой Windows

Далее во всех открытых диалогах, необходимо нажать «OK», чтобы сохранить
изменения. Теперь можно создать ярлык на рабочем столе со следующим
адресом: ``\textless{}путь с исполняемому файлу интерпретатора python
\textgreater{}\textbackslash{}pythonw.exe'' ``\textless{}путь к Beremiz\textgreater{}\textbackslash{}beremiz\textbackslash{}Beremiz.py''.


\section{Руководство программиста}
\label{usage_guide/index::doc}\label{usage_guide/index:id1}

\subsection{Обращение к программе. Входные и выходные данные}
\label{usage_guide/overview::doc}\label{usage_guide/overview:id1}
Общая схема по созданию прикладной программы в среде разработки Beremiz
представлена на рис. 1. Входными данными являются программные модули,
написанные пользователем (в большинстве случаев инженером по
автоматизации) на текстовых (ST, IL) и/или графических (FBD, SFC, LD)
языках в соответствии со стандартом IEC 61131-3, объединённые в проект.
Каждый такой проект представлен в формате XML и хранится в отдельной
папке.

Выходными данными является сгенерированный исходный код и исполняемый
файл:
\begin{itemize}
\item {} 
Файл \textless{}название проекта\textgreater{} содержащий промежуточный код на языке ST,
сгенерированный для всех программных модулей и ресурсов,
транслируемый в язык C;

\item {} 
Файлы: config.c config.h, POUS.h, POUS.c и файлы, соответствующие
ресурсам - содержат код (на языке C) реализации алгоритмов и логики
работы программных модулей и ресурсов проекта;

\item {} 
Файлы plc\_common\_main.c и plc\_debugger.c содержат код специфичный для
целевой архитектуры и код для отладки прикладной программы на целевом
устройстве из среды разработки Beremiz соответственно;

\item {} 
Файлы, содержащие код драйверов на языке С для взаимодействия с
внешними модулями УСО;

\item {} 
Исполняемый файл в виде динамической библиотеки (с расширением so),
компилируемый из этих вышеперечисленных C файлов.

\end{itemize}

Сгенерированный C код, с помощью кросскомпилятора, запущенного под
UNIX-подобной оболочкой, компилируется в исполняемый бинарный файл,
представленный в виде библиотеки.

Исполняемый файл, благодаря средствам Beremiz, может быть размещен на
целевом устройстве через локальную сеть.

На целевом устройстве исполняемый файл запускается и в процессе работы
выполняет следующие действия (см. \hyperref[usage_guide/overview:image1]{Рисунок \ref{usage_guide/overview:image1} }):
\begin{itemize}
\item {} 
С помощью драйверов модулей УСО обменивается данными с внешними
модулями;

\item {} 
Исполняет алгоритмы и логику, определенную пользователем в
программных модулях проекта;

\item {} 
Предоставляет данные для трансляции в системы верхнего уровня;

\item {} 
Сохраняет и транслирует информацию для отладки прикладных программ.

\end{itemize}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=7.10458in,height=5.11394in]{{image144}.png}
\caption{- Обобщенная схема инструментальной среды Beremiz}\label{usage_guide/overview:image1}\end{figure}


\subsection{Основные термины и определения}
\label{usage_guide/terms_and_definitions::doc}\label{usage_guide/terms_and_definitions:id1}
\textbf{IEC 61131-3} - раздел международного стандарта МЭК 61131 (также
существует соответствующий европейский стандарт EN 61131), описывающий
языки программирования для программируемых логических контроллеров.

\textbf{Среда разработки для языков стандарта IEC 61131-3} - система
программных средств, используемая инженерами по автоматизации, для
разработки прикладного программного обеспечения на высокоуровневых
языках стандарта IEC 61131-3 под различные целевые платформы, которая
включает в себя:

Текстовые и графические редакторы языков стандарта IEC 61131-3;

Транслятор диаграмм графических языков в текстовый язык;

Транслятор текстового языка в язык C;

Механизмы плагинов для взаимодействия с модулями УСО;

Механизмы добавления компиляторов под целевую платформу;

Механизмы соединений с целевыми устройствами;

Отладчик.

\textbf{Модули УСО} - модули ввода/вывода, обеспечивающие подключение
датчиков и исполнительных механизмов.

\textbf{Целевое устройство} - аппаратное средство с определённой архитектурой
процессора, на котором могут исполняться различные исполняемые файлы,
обращающиеся с помощью него к модулям УСО.

\textbf{Плагин для модуля УСО} - интерфейс, состоящий из специальных
драйверов и элементов пользовательского интерфейса для среды разработки
Beremiz, позволяющий связывать переменные модулей УСО с переменными
программных модулей, из которых состоит проект.

\textbf{Проект} - совокупность программных модулей (программ, функциональных
блоков, функций), плагинов внешних модулей УСО, ресурсов,
пользовательских типов данных, сборка (компиляция и компоновка) которых,
представляет собой прикладную программу для целевого устройства. Каждый
проект сохраняется в отдельном файле.

\textbf{Переменная} - область памяти, в которой находятся данные, с которыми
оперирует программный модуль.

\textbf{Ресурс} - элемент, отвечающий за конфигурацию проекта: глобальные
переменные и экземпляры проекта, связываемыми с программными модулями
типа «Программа» и задачами.

\textbf{Программный модуль} - элемент, представляющий собой функцию,
функциональный блок или программу. Каждый программный модуль состоит из
раздела объявлений и кода. Для написания всего кода программного
используется только один из языков программирования стандарта IEC
61131-3.

\textbf{Функция} - программный модуль, который возвращает только единственное
значение, которое может состоять из одного и нескольких элементов (если
это битовое поле или структура).

\textbf{Функциональный блок} - программный модуль, который принимает и
возвращает произвольное число значений, а так же позволяет сохранять
своё состояние (подобно классу в различных объектно-ориентированных
языках). В отличие от функции функциональный блок не формирует
возвращаемое значение.

\textbf{Программа} - программный модуль, представляющий собой единицу
исполнения, как правило, связывается (ассоциируется) с задачей.

\textbf{Задача} - элемент представляющий время и приоритет выполнения
программного модуля типа «Программа» в рамках экземпляра проекта.

\textbf{Экземпляр} - представляет собой программу, как единицу исполнения,
связанную (ассоциированную) с определённой задачей. Так же, как
экземпляр, рассматриваются переменные, определённые в программных
модулях: программа и функциональный блок.

\textbf{Пользовательский тип данных} - тип данных, добавленный в проект и
представляющий собой: псевдоним существующего типа, поддиапазон
существующего типа, перечисление, массив или структуру.


\subsection{Основные компоненты среды Beremiz}
\label{usage_guide/ide_components:beremiz}\label{usage_guide/ide_components::doc}
Пользовательский интерфейс среды разработки Beremiz состоит из следующих
компонент:
\begin{itemize}
\item {} 
Главное меню программы;

\item {} 
Панель инструментов;

\item {} 
Дерево проекта;

\item {} 
Панель списка переменных и констант;

\item {} 
Панель настроек проекта;

\item {} 
Панель файлов проекта;

\item {} 
Панель отображения промежуточного кода;

\item {} 
Текстовые редакторы языков ST и IL;

\item {} 
Графические редакторы языков FBD, SFC, LD;

\item {} 
Панель редактирования ресурса;

\item {} 
Панель экземпляров проекта;

\item {} 
Панель библиотеки функций и функциональных блоков;

\item {} 
Отладочная консоль;

\item {} 
Поиск элементов в проекте;

\item {} 
Панель отладки;

\item {} 
Панель графика изменения значения переменной в режиме отладки.

\end{itemize}

Далее подробно рассказано про каждый компонент среды разработки Beremiz
в отдельности.


\subsubsection{Главное меню программы}
\label{usage_guide/ide_components:id1}
Главное меню программы (см. \hyperref[usage_guide/ide_components:image2]{Рисунок \ref{usage_guide/ide_components:image2} }) содержит следующие пункты:
\begin{itemize}
\item {} 
«Файл»;

\item {} 
«Редактировать»;

\item {} 
«Вид»;

\item {} 
«Помощь».

\end{itemize}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.53125in,height=0.28542in]{{image21}.png}
\caption{– Главное меню программы}\label{usage_guide/ide_components:image2}\end{figure}

Часть операций, выполняемых с помощью выбора определённого пункта меню
мышью, могут быть исполнены с помощью «горячих клавиш». На выбор
пользователя представлено два механизма обработки горячих клавиш. Первый
механизм использует первые буквы названия пунктов меню, для выбора
пункта необходимо нажать (ALT + ‘Клавиша первой буквы названия пункта в
главном меню’) затем можно выбрать операцию или подменю, нажав на
клавиатуре первую букву названия соответствующего пункта. Второй
механизм использует установленные клавиатурные сочетания, далее будет
подробно описан каждый пункт меню и соответствующая ему (если
определена) «горячая клавиша».

Меню «Файл» предназначено для работы с проектом и предоставляет
следующие пункты:
\begin{itemize}
\item {} 
«Новый» - создание нового проекта (CTRL + N);

\item {} 
«Открыть» - открытие существующего проекта (CTRL + O);

\item {} 
«Недавние проекты» - быстрое открытие одного из десяти последних,
недавно редактированных проектов;

\item {} 
«Сохранить» - сохранение текущего проекта пункт (CTRL + S);

\item {} 
«Сохранить как» - сохранение текущего проекта в папку отличную от
той, в которой он сохранён на данный момент (CTRL + SHIFT + S);

\item {} 
«Закрыть вкладку» - закрытие активной вкладки (например, вкладки
переменных плагина, конфигурации и т.д.) для открытого проекта (CTRL
+ W);

\item {} 
«Закрыть проект» - закрыть текущий, открытый проект (CTRL + SHIFT +
W);

\item {} 
«Настройки страницы» - настройка параметров страницы для печати на
принтере активной программы, представленной в виде диаграммы (CTRL +
ALT + P);

\item {} 
«Просмотр» - предварительный просмотр результата перед печатью на
принтере активной программы (CTRL + SHIFT + P);

\item {} 
«Печать» - печать на принтере активной программы (CTRL + P);

\item {} 
«Выход» - закрытие текущего проекта и выход из программы Beremiz
(CTRL+ Q).

\item {} 
Меню «Редактировать» предназначено для работы с редакторами языков
стандарта МЭК 61131-3 и предоставляет следующие возможности:

\item {} 
«Отмена» - отмена последней манипуляции в редакторе (CTRL + Z);

\item {} 
«Повторить» повтор отменённой манипуляции в редакторе (CTRL + Y);

\item {} 
«Вырезать» - удалить в буфер обмена выделенный(е) элемент(ы) в
редакторе (CTRL + X);

\item {} 
«Копировать» - копировать в буфер обмена выделенный(е) элемент(ы) в
редакторе (CTRL + C);

\item {} 
«Вставить» - вставить из буфера обмена находящиеся там элемент(ы) в
редактор (CTRL + V);

\item {} 
«Поиск» - поиск в текущем функциональном блоке (CTRL + F);

\item {} 
«Поиск следующего» - подсветка следующего вхождения строки поиска
(CTRL+K);

\item {} 
«Поиск предыдущего» - подсветка предыдущего вхождения строки поиска
(CTRL + SHIFT + K);

\item {} 
«Поиск в проекте» - вызов диалога поиска данных в проекте (CTRL +
SHIFT + F);

\item {} 
«Добавить элемент» - добавление одного из следующих элемента в
текущий проект:

\item {} 
«Тип данных» - нового типа данных;

\item {} 
«Функция» - новой функции;

\item {} 
«Функциональный блок» - нового функционального блока;

\item {} 
«Программа» - новую программу;

\item {} 
«Ресурс» - новый ресурс;

\item {} 
плагины для модулей УСО;

\item {} 
«Выделить всё» - выделение всех элементов в активной вкладке
редактора (CTRL +A);

\item {} 
«Удалить» - удаление программного модуля, выделенного в дереве
проекта.

\end{itemize}

Меню «Вид» предназначено для работы с редакторами языков стандарта
IEC-61131 и предоставляет следующие возможности:
\begin{itemize}
\item {} 
«Обновить» - обновление данных и снятие выделения в редакторе (CTRL +
R);

\item {} 
«Очистить ошибки» - очистка указателей ошибок в редакторе (CTRL + K);

\item {} 
«Приближение» - пункт, в котором можно выбрать в процентах величину
масштаба;

\item {} 
«Сменить представление» - убирает все панели, оставляя только рабочее
поле(F12)

\item {} 
«Сброс расположения панелей» - восстановление расположения панелей
Beremiz в исходное состояние.

\end{itemize}

Меню «Помощь» предназначено для обращения к выводу информации в виде
диалога о создателях данной среды - пункт «О программе».


\subsubsection{Панель инструментов}
\label{usage_guide/ide_components:id2}
Панель инструментов представляет собой панель с кнопками для быстрого
обращения к часто используемым функциям среды разработки Beremiz. Она
состоит из нескольких панелей, содержащих кнопки: главного меню, сборки
проекта и установки связи с целевым устройством. Подробнее об этих
панелях рассказано ниже. При редактировании программных модулей,
написанных на графических языках, появляются дополнительные панели с
кнопками. Они рассмотрены при описании редакторов графических языков
стандарта IEC 61131-3 (см. п. 5.7).

Кнопки главного меню

Панель инструментов, содержащая кнопки главного меню представлена на
\hyperref[usage_guide/ide_components:image3]{Рисунок \ref{usage_guide/ide_components:image3} }.

Список кнопок и их функций описывается в таблице 1.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.66732in,height=0.4584in]{{image31}.png}
\caption{– Панель инструментов}\label{usage_guide/ide_components:image3}\end{figure}

Таблица 1 – Кнопки панели инструментов

\noindent\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Внешний вид кнопки
\unskip}\relax &\textsf{\relax 
Название кнопки
\unskip}\relax &\textsf{\relax 
Функция кнопки
\unskip}\relax \\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image41}.png}
&
Новый проект
&
Создать новый проект
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image51}.png}
&
Открыть проект
&
Открыть существующий
проект
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image61}.png}
&
Сохранить
&
Сохранить текущий
проект
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image71}.png}
&
Сохранить как
&
Сохранить текущий
проект в определенную
папку
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image81}.png}
&
Печать
&
Печать на принтере
текущей программы
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image91}.png}
&
Отмена
&
Отмена последней
манипуляции в
редакторе
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image101}.png}
&
Повторить
&
Повтор отмененной
манипуляции в
редакторе
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image111}.png}
&
Вырезать
&
Удалить в буфер
обмена выделенные в
редакторе фрагменты
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image12}.png}
&
Вставить
&
Вставить фрагменты из
буфера обмена в
редактор
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image13}.png}
&
Поиск в проекте
&
Вызов диалога поиска
данных в проекте
\\
\hline\end{tabulary}


Кнопки сборки проекта и установки связи с целевым устройством

Панель, содержащая кнопки сборки проекта и соединения с целевым
устройством, позволяет скомпилировать и скомпоновать текущий проект и, в
случае, если эта операция завершилась успешно (данную информацию можно
увидеть в отладочной консоли (см. п. 5.12.)), передать и запустить
полученный исполняемый файл на целевом устройстве.

Часть кнопок данной панели показана на \hyperref[usage_guide/ide_components:image14]{Рисунок \ref{usage_guide/ide_components:image14} }.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.70857in,height=0.46882in]{{image14}.png}
\caption{– Панель сборки проекта и соединения с целевым устройством}\label{usage_guide/ide_components:image14}\end{figure}

Таблица 2 – Кнопки сборки проекта и связи с целевым устройством на
панели инструментов

\noindent\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Внешний вид кнопки
\unskip}\relax &\textsf{\relax 
Название кнопки
\unskip}\relax &\textsf{\relax 
Функция кнопки
\unskip}\relax \\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image15}.png}
&
Сборка проекта в
директории сборки
&
Полная
сборка(компиляция и
компоновка) текущего
проекта в папку
build, находящийся в
папке, где хранится
проект
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image16}.png}
&
Очистить директорию
сборки проекта
&
Удаление папки build,
где был собран проект
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image17}.png}
&
Подключиться к
целевому ПЛК
&
Соединиться с целевым
устройством по адресу
URI, который был
указан в настройках
проекта
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image18}.png}
&
Показать код,
сгенерированный
PLCGenerator
&
Показать код
скомпилированного
проекта языке ST
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image19}.png}
&
Передать ПЛК
&
Перенести исполняемый
файл, полученный в
ходе сборки проекта,
на целевое устройство
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image20}.png}
&
Запустить ПЛК
&
Запустить на
исполнение собранную
прикладную программу
на целевом устройстве
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image211}.png}
&
Остановить запущенный
ПЛК
&
Остановить исполнение
прикладной программы
на целевом устройстве
\\
\hline\end{tabulary}


В зависимости от того, произведено в настоящий момент времени соединение
с целевым устройством или выполняется ли прикладная программа на нём,
появляются и скрываются некоторые кнопки.

На \hyperref[usage_guide/ide_components:image22]{Рисунок \ref{usage_guide/ide_components:image22} } приведено состояние данной в панели, когда соединение с
целевым устройством установлено и на нём уже есть прикладная программа.
Соответственно, можно запустить с помощью кнопки «Запуск прикладной
программы» её или передать новую, используя кнопку «Передача прикладной
программы».
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.39097in,height=0.44792in]{{image22}.png}
\caption{- Панель инструментов сборки проекта и соединения с целевым устройством}\label{usage_guide/ide_components:image22}\end{figure}

В случае, когда при установке соединения произошли ошибки, данная
информация будет выведена в отладочную консоль. Далее
будет рассмотрен компонент «Дерево проекта», который представляет
структуру элементов, составляющих проект.


\subsubsection{Дерево проекта}
\label{usage_guide/ide_components:id3}
Дерево проекта обычно расположено в левой части окна среды разработки
Beremiz (см. \hyperref[usage_guide/ide_components:image23]{Рисунок \ref{usage_guide/ide_components:image23} }) и отображает структуру элементов, из которых
состоит проект.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.98889in,height=3.54097in]{{image23}.png}
\caption{– Дерево проекта}\label{usage_guide/ide_components:image23}\end{figure}

В роли элементов могут выступать:
\begin{itemize}
\item {} 
Ресурсы;

\item {} 
Программные модули (функции, функциональные блоки и программ) и их
составные части;

\item {} 
Типы данных;

\item {} 
Плагины модулей УСО.

\end{itemize}

Дерево проекта позволяет добавлять, удалять элементы. Операции
копирования и вставки только доступны для программных модулей.

Добавление элемента в дерево проекта

В правом нижнем углу дерева проекта находится кнопка «+» (см. \hyperref[usage_guide/ide_components:image24]{Рисунок \ref{usage_guide/ide_components:image24} }),
при нажатии на которую, появляется меню для выбора добавления
необходимого элемента в проект.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.31458in,height=4.57569in]{{image24}.png}
\caption{– Всплывающее меню добавления элементов проекта}\label{usage_guide/ide_components:image24}\end{figure}

В случае добавления программного модуля, т.е. выбора пункта «Функция»,
«Функциональный блок» или «Программа», появится диалог «Создать новый
программный модуль» (см. \hyperref[usage_guide/ide_components:image25]{Рисунок \ref{usage_guide/ide_components:image25} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.13585in,height=2.33366in]{{image25}.png}
\caption{– Диалог добавления программного модуля}\label{usage_guide/ide_components:image25}\end{figure}

В данном диалоге три поля:
\begin{itemize}
\item {} 
«Имя программного модуля»;

\item {} 
«Тип программного модуля»;

\item {} 
«Язык».

\end{itemize}

Имя, присвоенное по умолчанию, может быть заменено на имя,
соответствующее назначению данного программного модуля. В зависимости от
того, какой программный модуль был выбран во всплывающем меню, в поле
«Тип программного модуля» будет подставлено именование данного
программного модуля. В поле «Язык» необходимо выбрать из списка (см.
\hyperref[usage_guide/ide_components:image26]{Рисунок \ref{usage_guide/ide_components:image26} }) один из языков стандарта IEC 61131-3 (IL, ST, LD, FBD, SFC), на
котором будут реализованы алгоритмы и логика работы данного добавляемого
программного модуля.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.12544in,height=3.41714in]{{image26}.png}
\caption{– Выбор языка программного модуля}\label{usage_guide/ide_components:image26}\end{figure}

В случае выбора добавления типа данных, появится диалог (см. \hyperref[usage_guide/ide_components:image27]{Рисунок \ref{usage_guide/ide_components:image27} }), в
котором необходимо указать механизм создания нового типа данных
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.80347in,height=2.43611in]{{image27}.png}
\caption{– Добавление пользовательского типа данных}\label{usage_guide/ide_components:image27}\end{figure}

Добавление нескольких элементов одного типа, например нескольких
программ, функций, функциональных блоков приводит к их группировке в
дереве проекта. Еще одним способом добавления нового элемента
является нажатие правой клавиши мыши по определённому разделу в
дереве проекта. Например, при нажатии на «Функциональные блоки»,
появится всплывающее меню (см. \hyperref[usage_guide/ide_components:image28]{Рисунок \ref{usage_guide/ide_components:image28} }). В данном меню можно выбрать
«Добавить программный модуль» или «Вставить программный модуль», если
он был скопирован в буфер обмена.

Добавление нового элемента или выбор существующего в дереве проекта
приводит к появлению панели редактирования и настроек соответствующего
элемента:
\begin{itemize}
\item {} 
Панель настроек проекта;

\item {} 
Панель, содержащая текстовый редактор языков ST и IL;

\item {} 
Панель, содержащая графические редакторы диаграмм языков FBD, SFC,
LD;

\item {} 
Панель настроек ресурса;

\item {} 
Панель редактирование типа данных;

\item {} 
Панели настроек плагинов модулей УСО.

\end{itemize}

Каждая вышеперечисленная панель редактирования будет рассмотрена в
последующих пунктах.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.80208in,height=3.08333in]{{image28}.png}
\caption{– Всплывающее меню добавления и вставки программного модуля}\label{usage_guide/ide_components:image28}\end{figure}

Удаление элемента в дереве проекта

Удаление осуществляется наведением на определённый элемент в дереве
проекта и нажатием на него правой клавишей мыши, а далее в появившемся
меню выбирается пункт «Удалить» (см. \hyperref[usage_guide/ide_components:image29]{Рисунок \ref{usage_guide/ide_components:image29} })
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.78125in,height=1.35417in]{{image29}.png}
\caption{– Удаление элемента}\label{usage_guide/ide_components:image29}\end{figure}

Переименование, копирование и вставка программных модулей

Дерево проекта позволяет выполнять операции переименования, копирования
и вставки для программных модулей. Копирование или переименование
осуществляются с помощью нажатия правой клавиши мыши на элемент (см.
\hyperref[usage_guide/ide_components:img29]{Рисунок \ref{usage_guide/ide_components:img29} }), соответствующий программному модулю в дереве проекта, и выбор
соответствующего пункта появившегося меню.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.77083in,height=1.35417in]{{image29}.png}
\caption{– Копирование и переименование элемента}\label{usage_guide/ide_components:img29}\end{figure}

Вставка программного модуля осуществляется в меню (нажатие правой
клавишей мыши по данному элементу) корневого элемента дерева проекта,
соответствующего проекту (см. \hyperref[usage_guide/ide_components:image30]{Рисунок \ref{usage_guide/ide_components:image30} }):
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.76736in,height=1.06389in]{{image30}.png}
\caption{– Вставка программного модуля}\label{usage_guide/ide_components:image30}\end{figure}

Другим способом выполнения вышеописанной операции является вызов меню
для элемента группировки программных модулей одного типа (см. \hyperref[usage_guide/ide_components:image31]{Рисунок \ref{usage_guide/ide_components:image31} }).

Далее приводится описание панели переменных и констант, которая
присутствует при редактировании проекта, ресурса и программных модулей
(функции, функционального блока, программы).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.67708in,height=0.88542in]{{image311}.png}
\caption{– Вставка программного модуля}\label{usage_guide/ide_components:image31}\end{figure}


\subsubsection{Панель списка переменных и констант}
\label{usage_guide/ide_components:id4}
Панель списка переменных и констант (см. \hyperref[usage_guide/ide_components:image32]{Рисунок \ref{usage_guide/ide_components:image32} }) отображает с помощью
таблицы переменные и константы, соответствующие выбранному программному
модулю, ресурсу или в целом проекту.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=7.45in,height=1.69514in]{{image32}.png}
\caption{– Панель переменных и констант}\label{usage_guide/ide_components:image32}\end{figure}

Каждая переменная имеет следующие параметры:
\begin{itemize}
\item {} 
Имя, представляющее собой уникальный идентификатор переменной в
пределах её области видимости и действия;

\item {} 
Класс: «Глобальный», «Вход», «Выход», «Вход/Выход», «Локальный»,
«Внешний», «Временный»;

\item {} 
Тип, определяющий тип переменной и может принадлежать базовому типу
(в соответствии со стандартом IEC 61131-3), пользовательскому типу
(псевдониму и поддиапазону существующего типа, перечислению, массиву,
структуре) или типу функционального блока (стандартному или
пользовательскому);

\item {} 
Размещение - идентификатор, необходимый для связывания данной
переменной с переменной плагина модуля УСО;

\item {} 
Исходное значение значение - инициализация переменной некоторым
начальным значением;

\item {} 
Настройка - задание константности, реманентности (сохранение её
значения в энергонезависимой памяти) и нереманентности переменной;

\item {} 
Описание - комментарий к назначению данной переменной или константы.

\end{itemize}

Первый символ имени переменной или константы должен быть буквой, или
символом подчеркивания, далее могут следовать цифры, буквы латинского
алфавита и символы подчеркивания. Набор возможных вариантов классов
переменных зависит от типа элемента проекта, редактирования которого
осуществляется. Двойной клик на полю «Размещение» вызывает появление
кнопки «...», показанной на \hyperref[usage_guide/ide_components:image33]{Рисунок \ref{usage_guide/ide_components:image33} }:
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.45833in,height=0.9375in]{{image33}.png}
\caption{- Поле «Размещение» панели переменных и констант}\label{usage_guide/ide_components:image33}\end{figure}

Нажатие на данную кнопку приводит к появлению диалога «Просмотр
директорий» (см. \hyperref[usage_guide/ide_components:image34]{Рисунок \ref{usage_guide/ide_components:image34} }), т.е. списка переменных модулей УСО, которые
могут быть связанны с переменой в панели переменных и констант. При
выборе в данном диалоге определённой переменной и нажатии клавиши «OK» в
поле «Адрес» будет добавлен адрес переменной внешнего модуля УСО.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.79306in,height=3.0625in]{{image34}.png}
\caption{- Диалог «Просмотр адресов», вызываемый из поля «Адрес»}\label{usage_guide/ide_components:image34}\end{figure}

Поле опции позволяет определить переменную как константу.
Соответственно, если компилятор обнаружит в коде фрагмент, в котором
происходит изменение этой переменной - будет выведена ошибка компиляции
«Assignment to constant variables is not be allowed» в «Отладочной
консоли». Квалификатор «Константа» не может быть использован в
объявлении функциональных блоков. Добавление, удаление и перемещение
переменных происходит с помощью специальных кнопок на панели переменных
и констант. Описания данных кнопок представлены в таблице 3.

Панель переменных и констант предоставляет возможность фильтровать
отображаемые переменные по их конкретным классам («Вход» ,«Выход»,
«Вход/Выход»,

«Внешний», «Локальный», «Временный») или сгруппированным классам
(«Интерфейс» и «Переменные»). Данная операция выполняется с помощью
функции «Фильтр класса» (см. \hyperref[usage_guide/ide_components:image35]{Рисунок \ref{usage_guide/ide_components:image35} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.30486in,height=2.82569in]{{image35}.png}
\caption{- Фильтрация отображения переменных в панели переменных и констант}\label{usage_guide/ide_components:image35}\end{figure}

Таблица 3 - Кнопки добавления, удаление и перемещения переменных на
панели переменных и констант

\noindent\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Внешний вид кнопки
\unskip}\relax &\textsf{\relax 
Название кнопки
\unskip}\relax &\textsf{\relax 
Функция кнопки
\unskip}\relax \\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image36}.png}
&
Добавить переменную
&
Добавить новую
переменную в панель
переменных и констант
со значениями по
умолчанию
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image37}.png}
&
Удалить переменную
&
Удалить выделенную
переменную или
константу
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image38}.png}
&
Переместить
переменную вверх
&
Перемещение
переменной в таблице
переменных и констант
вверх на одну позицию
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image39}.png}
&
Переместить
переменную вниз
&
Перемещение
переменной в таблице
переменных и констант
вниз на одну позицию
\\
\hline\end{tabulary}



\subsubsection{Панель настройки проекта}
\label{usage_guide/ide_components:id5}
Панель редактирования проекта (см. \hyperref[usage_guide/ide_components:image40]{Рисунок \ref{usage_guide/ide_components:image40} }) состоит из панели переменных
и констант, а также настроек сборки проекта и данных о проекте.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.29348in,height=0.38641in]{{image40}.png}
\caption{- Панели настройки проекта}\label{usage_guide/ide_components:image40}\end{figure}

Настройки сборки проекта (см. \hyperref[usage_guide/ide_components:image41]{Рисунок \ref{usage_guide/ide_components:image41} }) позволяют задать следующие
параметры:
\begin{itemize}
\item {} 
«URI системы исполнения» - унифицированный (единообразный)
идентификатор ресурса, в данном случае под ресурсом понимается
целевое устройство. Данный адрес необходим для режима отладки.

\item {} 
«Запретить расширения» - установка данного флага позволяет не
учитывать при сборке проекта внешние плагины;

\item {} 
«Библиотеки» - подключаемые дополнительные библиотеки:
«Native\_Library», «Python\_Library», «SVGUI\_Library»;

\item {} 
«Целевая платформа» - выбор из списка компилятора для архитектуры
целевого устройства;

\item {} 
«Компилятор» - имя исполняемого файла компилятора (если он определён
в глобальных переменных среды), либо полный путь к нему;

\item {} 
«CFLAGS» - указание флагов С компилятора;

\item {} 
«Линковщик» - имя исполняемого файла компоновщика (если он определён
в глобальных переменных среды), либо полный путь к нему;

\item {} 
«LDFLAGS» - указание флагов компоновщика;

\end{itemize}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.37986in,height=3.07847in]{{image411}.png}
\caption{- Панель с настройками проекта}\label{usage_guide/ide_components:image41}\end{figure}

Также в настройках сборки проекта имеются две кнопки, описание которых
приведено в таблице 4.

Таблица 4 - Кнопки в панели настройки сборки проекта

\noindent\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Внешний вид кнопки
\unskip}\relax &\textsf{\relax 
Название кнопки
\unskip}\relax &\textsf{\relax 
Функция кнопки
\unskip}\relax \\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image42}.png}
&
МЭК - код
&
Вызов «Панели
отображения
промежуточного кода»
(см. п. 5.5.1), для
вывода кода, из
которого генерируется
ST код всего проекта
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image43}.png}
&
Файлы проекта
&
Вызов «Панели файлов
проекта», в которой
можно выбрать файлы
необходимые для
передачи на целевое
устройство вместе с
исполняемым файлом
(см. п. 5.5.2)
\\
\hline\end{tabulary}


Вкладка «Проект» (см. \hyperref[usage_guide/ide_components:image44]{Рисунок \ref{usage_guide/ide_components:image44} }) позволяет задать: имя проекта, версию
проекта, имя продукта, версию продукта и релиз продукта.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=7.09167in,height=2.40417in]{{image44}.png}
\caption{– Вкладка с данными проекта}\label{usage_guide/ide_components:image44}\end{figure}

Вкладка «Автор» (см. \hyperref[usage_guide/ide_components:image45]{Рисунок \ref{usage_guide/ide_components:image45} }) позволяет задать: Имя компании, URL-адрес
компании, Имя автора, Название организации.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.94028in,height=1.96736in]{{image45}.png}
\caption{– Вкладка данные об авторе проекта}\label{usage_guide/ide_components:image45}\end{figure}

Вкладка «Графика» (см. \hyperref[usage_guide/ide_components:image46]{Рисунок \ref{usage_guide/ide_components:image46} }) позволяет задать размеры страницы и
разрешение сетки для редакторов диаграмм графических языков FBD, LD и
SFC.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.31944in,height=2.37431in]{{image46}.png}
\caption{– Вкладка графика}\label{usage_guide/ide_components:image46}\end{figure}

Вкладка «Прочее», изображенная на \hyperref[usage_guide/ide_components:image47]{Рисунок \ref{usage_guide/ide_components:image47} }, позволяет выбрать язык
интерфейса для среды разработки Beremiz и указать дополнительное
текстовое описание для проекта.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.63207in,height=1.61956in]{{image47}.png}
\caption{– Вкладка с настройками языка и описанием проекта}\label{usage_guide/ide_components:image47}\end{figure}

При запуске среды разработки Beremiz языком по умолчанию является язык,
соответствующий текущей локали операционной системы, если файл для
данной локали присутствуют. В случае отсутствия данных файлов,
устанавливается английская локаль, которая доступна всегда. Файлы
доступных локалей располагаются в папке beremiz/locale.

Панель отображения промежуточного кода

Данная панель (см. \hyperref[usage_guide/ide_components:image48]{Рисунок \ref{usage_guide/ide_components:image48} }) представляет собой текстовый редактор,
отображающий с подсветкой синтаксиса и нумерацией строк код на языке ST,
доступный только для чтения, без возможности редактирования.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.40208in,height=2.05in]{{image48}.png}
\caption{– Панель отображения промежуточного кода на языке ST}\label{usage_guide/ide_components:image48}\end{figure}

Открытие данной панели доступно после сборки проекта с помощью
соответствующей кнопки (см. таблицу 2).

Панель файлов проекта

Панель файлов проекта (см. \hyperref[usage_guide/ide_components:image49]{Рисунок \ref{usage_guide/ide_components:image49} }) содержит встроенный проводник файлов
(справа), в котором файлы могут быть выделены и перенесены в левую
часть.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.20834in,height=2.97826in]{{image49}.png}
\caption{– Вкладка файлы проекта}\label{usage_guide/ide_components:image49}\end{figure}

Все манипуляции с файлами осуществляются с помощью кнопок, расположенных
в середине данной панели. Их описание приведено в таблице 5.

Таблица 5 - Кнопки в панели файлов проекта

\noindent\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Внешний вид кнопки
\unskip}\relax &\textsf{\relax 
Название кнопки
\unskip}\relax &\textsf{\relax 
Функция кнопки
\unskip}\relax \\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image37}.png}
&
Удалить файл из левой
директории
&
Удаление выделенного
файла из левого
списка добавленных
файлов в проект
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image50}.png}
&
Скопировать файл из
правой директории в
левую
&
Добавить выделенный
файл из проводника
файлов в проект
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image511}.png}
&
Скопировать файл из
левой директории в
правую
&
Добавить в текущую
папку проводника
файлов слева
выделенный файл в
списке файлов проекта
\\
\hline\end{tabulary}


Данные файлы будут переданы на целевое устройство вместе с исполняемым
файлом. Как правило, этими дополнительными файлами проекта являются
сторонние библиотеки, необходимые для корректной работы плагинов модулей
УСО.


\subsubsection{Текстовый редактор языков ST и IL}
\label{usage_guide/ide_components:st-il}
Текстовый редактор языков ST и IL (см. \hyperref[usage_guide/ide_components:image52]{Рисунок \ref{usage_guide/ide_components:image52} }) позволяет создавать и
редактировать алгоритмы и логику выполнения программных модулей на
языках ST и IL.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.10833in,height=2.63889in]{{image52}.png}
\caption{– Текстовый редактор языков ST и IL}\label{usage_guide/ide_components:image52}\end{figure}

Он обеспечивают следующие возможности:
\begin{itemize}
\item {} 
Подсветку синтаксиса кода, написанного пользователем, т.е. выделения
особыми параметрами шрифта ключевых слов данных языков;

\item {} 
Нумерации строк, что может быть полезным при возникновении ошибок в
программе, т.к. транслятор кода ST в C выдаёт номер строки, в которой
найдена ошибка;

\item {} 
Сворачивание кода структурных элементов языка: определения функции,
определение типа и т. Д.

\end{itemize}

Увеличение или уменьшение размера шрифт выполняется с помощью Ctrl +
\textless{}колёсико мыши\textgreater{}.

Описание синтаксиса, основных конструкций и примеров использования языков
ST и IL приведены в описании языков стандарта МЭК 61131-3.


\subsubsection{Графические редакторы диаграмм языков FBD, SFC, LD}
\label{usage_guide/ide_components:fbd-sfc-ld}
Данные редакторы позволяют создавать и редактировать алгоритмы и логику
выполнения программных модулей, написанных на языках FBD, SFC и LD.

Редактор языка FBD

Основными элементами языка FBD являются: переменные, функциональные
блоки и соединения. При редактировании FBD диаграммы, в панели
инструментов появляется следующая панель (см. \hyperref[usage_guide/ide_components:image53]{Рисунок \ref{usage_guide/ide_components:image53} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.44826in,height=0.48965in]{{image53}.png}
\caption{– Панель редактирования FBD диаграмм}\label{usage_guide/ide_components:image53}\end{figure}

С помощью данной панели можно добавить все элементы языка FBD
(назначение каждой кнопки описано в таблице 6).

Таблица 6 - Кнопки в панели файлов проекта

\noindent\begin{tabular}{|p{0.317\linewidth}|p{0.317\linewidth}|p{0.317\linewidth}|}
\hline
\textsf{\relax 
Внешний вид кнопки
\unskip}\relax &\textsf{\relax 
Название кнопки
\unskip}\relax &\textsf{\relax 
Функция кнопки
\unskip}\relax \\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image54}.png}
&
Выделение объектов на
диаграмме
&
Перевод указателя
мыши в состояние, при
котором можно
осуществлять
выделение объектов
редакторе одного из
графических языков
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image55}.png}
&
Перемещение

диаграммы
&
Перевод указателя
мыши в состояние, при
котором можно
изменять размеры
редактора одного из
графических языков, с
помощью его
перемещения
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image56}.png}
&
Создать новый
комментарий
&
Вызов диалога
создания комментария
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image57}.png}
&
Добавить переменную
&
Вызов диалога
добавления переменной
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image58}.png}
&
Добавить

функциональный блок
&
Вызов диалога
добавления
функционального блока
\\
\hline
\sphinxincludegraphics[width=0.27153in,height=0.27153in]{{image59}.png}
&
Добавить подключение
&
Вызов диалога
добавления соединения
\\
\hline\end{tabular}


Для этого необходимо указателем мыши выбрать необходимую кнопку и нажать
на свободное место в области редактирования FBD диаграммы. В зависимости
от выбранного элемента появятся определённые диалоги добавления данного
элемента.

Аналогичные действия можно выполнить с помощью всплывающего меню в
области редактирования FBD диаграмм. Вызов данного меню происходит
нажатием правой клавишей мыши и выбором пункта «Добавить», в котором
будет: «Блок», «Переменная», «Подключение», «Комментарий» (см. \hyperref[usage_guide/ide_components:image60]{Рисунок \ref{usage_guide/ide_components:image60} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.20605in,height=1.53261in]{{image60}.png}
\caption{- Всплывающее меню редактора языка FBD}\label{usage_guide/ide_components:image60}\end{figure}

Далее рассмотрено добавление каждого элемента в отдельности.

Добавление функционального блока

При добавлении функционального блока одним из описанных выше способов,
появится диалог «Свойства блока» (см. \hyperref[usage_guide/ide_components:image61]{Рисунок \ref{usage_guide/ide_components:image61} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.60833in,height=3.31181in]{{image611}.png}
\caption{– Свойства функционального блока}\label{usage_guide/ide_components:image61}\end{figure}

В данном диалоге приведено краткое описание функционального блока и
предоставлена возможность задать некоторые свойства (имя, количество
входов, порядок выполнения и т.д.).

Опция «Управление исполнением» добавляет в функциональный блок
дополнительные параметры EN/ENO, о которых подробнее рассказано в
приложении 5. Для сохранения изменений необходимо нажать «OK». Одним из
свойств является «Порядок исполнения».

Добавление (путем копирования существующего блока), удаление и
переименование функционального блока осуществляется при помощи команд
меню «Редактирование» в главном меню или с помощью всплывающего меню
диаграммы (см. \hyperref[usage_guide/ide_components:image61]{Рисунок \ref{usage_guide/ide_components:image61} }).

Следует отметить, что функциональный блок может быть так же добавлен из
«Панели библиотеки функций и функциональных блоков»,
перетаскиванием мыши (Drag\&Drop) выбранного блока на панель
редактирования диаграммы FBD.

Добавление переменной

Переменные добавляются из панели переменных и констант с помощью
перетаскивания (Drag\&Drop) левой клавишей мыши за область, выделенную
красным цветом на \hyperref[usage_guide/ide_components:image62]{Рисунок \ref{usage_guide/ide_components:image62} }, в область редактирования FBD диаграмм.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.77639in,height=2.9125in]{{image62}.png}
\caption{– Добавление переменной из панели переменных и констант}\label{usage_guide/ide_components:image62}\end{figure}

Изменить параметры переменной можно в диалоге «Свойства переменной» (см.
\hyperref[usage_guide/ide_components:image63]{Рисунок \ref{usage_guide/ide_components:image63} }), нажав на неё два раза левой клавишей мыши.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.02083in,height=2.75486in]{{image63}.png}
\caption{– Свойства переменной}\label{usage_guide/ide_components:image63}\end{figure}

В данном диалоге можно задать порядок исполнения переменной и изменить
её класс («Вход», «Выход», «Вход/Выход»).

Добавление подключения

В тех случаях, когда необходимо передать выходное значение одного
функционального блока на один из входов другого, удобно использовать
элемент «Подключение». При прямом соединении с помощью перетаскивания
выхода одного функционального блока к входу другого получится прямое
соединение с помощью чёрной соединительной линии. На схемах с большим
количеством функциональных блоков элемент «Подключение» позволяет
избежать пересечения прямых соединений, которые приводит к тому, что
схема становится менее понятной.

После выбора добавления элемента «Подключение» появится диалог «Свойства
подключения» (см. \hyperref[usage_guide/ide_components:image64]{Рисунок \ref{usage_guide/ide_components:image64} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.79525in,height=1.88235in]{{image64}.png}
\caption{- Диалог добавления подключения для FBD}\label{usage_guide/ide_components:image64}\end{figure}

В данном диалоге можно выбрать тип соединения: «Выходное соединение» -
для выходного значения, «Входное соединение» - для входного значения, а
так же необходимо указать имя данного соединения. На \hyperref[usage_guide/ide_components:image65]{Рисунок \ref{usage_guide/ide_components:image65} } представлен
пример использования соединений.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.11667in,height=1.57708in]{{image65}.png}
\caption{- Пример FBD диаграммы с использованием подключений}\label{usage_guide/ide_components:image65}\end{figure}

Функция «MAX» на выходе «OUT» имеет некоторое значение, которое с
помощью соединения «RESULT» передаётся на вход «IN1» в функцию «MIN». В
функции «MAX» используется соединение типа «Выходное соединение», в
функции «MIN» - типа «Входное соединение». Имена у этих соединений,
соответственно, одинаковые.

Добавление комментариев

Редактор FBD диаграмм (и остальные редакторы, о которых будет рассказано
ниже) позволяют добавлять комментарии на диаграмму. После выбора на
панели редактирования комментария и добавления его в область
редактирования появится диалог (см. \hyperref[usage_guide/ide_components:image66]{Рисунок \ref{usage_guide/ide_components:image66} }) для ввода текста
комментария.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.38235in,height=1.87814in]{{image66}.png}
\caption{– Диалог добавления комментария}\label{usage_guide/ide_components:image66}\end{figure}

После нажатия кнопки «ОК» комментарий появится на диаграмме(см. \hyperref[usage_guide/ide_components:image67]{Рисунок \ref{usage_guide/ide_components:image67} })
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.20069in,height=1.88194in]{{image67}.png}
\caption{– Добавленный комментарий к FBD диаграмме}\label{usage_guide/ide_components:image67}\end{figure}

Порядок выполнения функций и функциональных блоков

Последовательность исполнения функций и функциональных блоков
определяется порядком их выполнения. Автоматически он регламентируется
следующим образом: чем выше и левее расположен верхний левый угол,
описывающего функцию или функциональный блок прямоугольника, тем раньше
данная функция или функциональный будет выполнен.

Если обратиться к \hyperref[usage_guide/ide_components:image68]{Рисунок \ref{usage_guide/ide_components:image68} }, то порядок выполнения функций будет
следующим: 1 – CounterST0; 2 – CounterFBD0; 3 – CounterSFC0.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.60875in,height=1.55208in]{{image68}.png}
\caption{- Схема, содержащая функции с порядком выполнения (обсчета) по расположению}\label{usage_guide/ide_components:image68}\end{figure}

Данная опция «Порядок выполнения» выделена красным цветом на \hyperref[usage_guide/ide_components:image69]{Рисунок \ref{usage_guide/ide_components:image69} }.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.88194in,height=2.79444in]{{image69}.png}
\caption{- Свойство порядок выполнения функции или функционального блока}\label{usage_guide/ide_components:image69}\end{figure}

После задания порядка выполнения для каждой функции или функционального
блока на схеме в правом нижнем углу будет указан его порядковый номер
выполнения. Пример представлен на \hyperref[usage_guide/ide_components:image70]{Рисунок \ref{usage_guide/ide_components:image70} }.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.40555in,height=1.66667in]{{image70}.png}
\caption{- Схема, содержащая функции с порядком выполнения заданным вручную}\label{usage_guide/ide_components:image70}\end{figure}

Описание языка FBD, основных его конструкций и пример использования
приведены в приложении 5.

Редактор языка LD

Язык LD или РКС (Релейно-Контактные Схемы) представляет собой
графическую форму записи логических выражений в виде контактов и катушек
реле. Основными элементами языка LD являются: шина питания, катушка,
контакт. Добавить данные элементы, так же как и элементы языка FBD,
можно несколькими способами.

Как только активной становится вкладка с редактированием LD диаграммы, в
панели инструментов появляется панель (см. \hyperref[usage_guide/ide_components:image71]{Рисунок \ref{usage_guide/ide_components:image71} }) с элементами языка
LD.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.54216in,height=0.46882in]{{image711}.png}
\caption{- Панель редактирования LD диаграмм}\label{usage_guide/ide_components:image71}\end{figure}

Аналогично редактору языка FBD с помощью данной панели можно добавить
все элементы языка LD, а так же и FBD, т.к. есть возможность
комбинированного применения языков на одной диаграмме. В таблице 7
приведено описание кнопок данной панели. Описание остальных кнопок,
относящихся к языку FBD, находится в таблице 6.

Таблица 7 - Кнопки панели редактирования LD диаграммы

\noindent\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Внешний вид кнопки
\unskip}\relax &\textsf{\relax 
Название кнопки
\unskip}\relax &\textsf{\relax 
Функция кнопки
\unskip}\relax \\
\hline
\sphinxincludegraphics[width=0.26458in,height=0.26458in]{{image72}.png}
&
Создать новую шину
питания
&
Вызов диалога
создания новой шины
питания
\\
\hline
\sphinxincludegraphics[width=0.26458in,height=0.26458in]{{image73}.png}
&
Создать новую катушку
&
Вызов диалога
создания новой
катушки
\\
\hline
\sphinxincludegraphics[width=0.26458in,height=0.26458in]{{image74}.png}
&
Создать новый контакт
&
Вызов диалога
создания нового
контакта
\\
\hline\end{tabulary}


Во всплывающем меню для редактора LD диаграмм (см. \hyperref[usage_guide/ide_components:image75]{Рисунок \ref{usage_guide/ide_components:image75} }), так же как
и в панели инструментов помимо элементов LD языка, доступны элементы
языка FBD.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.51667in,height=1.92153in]{{image75}.png}
\caption{- Всплывающее меню редактора языка LD}\label{usage_guide/ide_components:image75}\end{figure}

Добавление шины питания

При добавлении шины питания, одним из описанных выше способов, появится
диалог «Свойства шины питания» (см. \hyperref[usage_guide/ide_components:image76]{Рисунок \ref{usage_guide/ide_components:image76} }).

В данном диалоге указываются следующие свойства:
\begin{itemize}
\item {} 
Тип шины питания: шина питания слева или шина питания справа;

\item {} 
Количество контактов на добавляемой шине питания.

\end{itemize}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.69608in,height=1.88726in]{{image76}.png}
\caption{- Свойство шины питания}\label{usage_guide/ide_components:image76}\end{figure}

На \hyperref[usage_guide/ide_components:image77]{Рисунок \ref{usage_guide/ide_components:image77} } приведены две добавленные шины питания: левая с тремя
контактами и правая с одним контактом.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.36275in,height=1.4875in]{{image77}.png}
\caption{- Шины питания на LD диаграмме}\label{usage_guide/ide_components:image77}\end{figure}

Добавление контакта

При добавлении контакта на LD диаграмму появится диалог «Редактирование
значения контакта» (см. \hyperref[usage_guide/ide_components:image78]{Рисунок \ref{usage_guide/ide_components:image78} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.3625in,height=2.04167in]{{image78}.png}
\caption{- Редактирование контакта}\label{usage_guide/ide_components:image78}\end{figure}

Данный диалог позволяет определить модификатор данного контакта:
\begin{itemize}
\item {} 
«Обычный»;

\item {} 
«Инверсия»;

\item {} 
«Нарастающий фронт»;

\item {} 
«Спадающий фронт».

\end{itemize}

Кроме того, диалог позволяет выбрать из списка «Имя» переменную,
«связываемую» с данным контактом. Следует отметить, что «связываемые»
переменные должны быть определены в панели переменных и констант для
данного программного модуля типом BOOL.

Еще одним способом добавления контакта на диаграмму является метод
Drag\&Drop из панели переменных и констант переменной типа BOOL и класса:
«Вход»,

«Вход/Выход», «Внешний», «Локальный», «Временный». Для этого необходимо
зажать левой кнопкой мыши за первый столбец (который имеет заголовок \#)
переменную, удовлетворяющую описанным выше критериям и перенести в
область редактирования диаграммы (см. \hyperref[usage_guide/ide_components:image79]{Рисунок \ref{usage_guide/ide_components:image79} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.01944in,height=2.20278in]{{image79}.png}
\caption{- Добавление контакт на диаграмму из панели переменных и констант}\label{usage_guide/ide_components:image79}\end{figure}

Добавление катушки

При добавлении катушки на LD диаграмму появится диалог «Редактирование
значения катушки» (см. \hyperref[usage_guide/ide_components:image80]{Рисунок \ref{usage_guide/ide_components:image80} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.51389in,height=2.60764in]{{image80}.png}
\caption{– Редактирование катушки}\label{usage_guide/ide_components:image80}\end{figure}

В данном диалоге можно определить модификатор данного контакта:
\begin{itemize}
\item {} 
«Обычный»;

\item {} 
«Инверсия»;

\item {} 
«Установить»;

\item {} 
«Сброс»;

\item {} 
«Нарастающий фронт»;

\item {} 
«Спадающий фронт».

\end{itemize}

Кроме того, производится выбор из списка «Имя» переменной, «связываемой»
с данным контактом. Эти переменные, как и для контактов, должны быть
определены в панели переменных и констант для данного программного
модуля типом BOOL.

Аналогично добавлению контакта с помощью Drag\&Drop можно добавить и
катушки, но в данном случае переменная должна относиться к классу
«Выход» (см. \hyperref[usage_guide/ide_components:image81]{Рисунок \ref{usage_guide/ide_components:image81} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.97485in,height=2.07843in]{{image811}.png}
\caption{- Добавление катушки на диаграмму из панели переменных и констант}\label{usage_guide/ide_components:image81}\end{figure}

Описание языка LD, основных конструкций и примера его использования
приведены в описании яызков стандарта МЭК 61131-3.

Редактор языка SFC

Основными элементами языка SFC являются: начальный шаг, шаг, переход,
блок действий, дивергенции, «прыжок». Программа на языке SFC состоит из
набора шагов, связанных переходами.

Как только активной становится вкладка с редактированием SFC диаграммы,
в панели инструментов появляется следующая панель (см. \hyperref[usage_guide/ide_components:image82]{Рисунок \ref{usage_guide/ide_components:image82} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.54902in,height=0.40959in]{{image82}.png}
\caption{- Панель редактирования SFC диаграмм}\label{usage_guide/ide_components:image82}\end{figure}

В таблице 8 приведено описание кнопок данной панели. Описание остальных
кнопок, относящихся к языку FBD и LD (за исключением катушки) и так же
находящихся на этой панели, приведены в таблицах 6 и 7 соответственно.

Таблица 8 - Кнопки панели редактирования LD диаграммы

\noindent\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Внешний вид кнопки
\unskip}\relax &\textsf{\relax 
Название кнопки
\unskip}\relax &\textsf{\relax 
Функция кнопки
\unskip}\relax \\
\hline
\sphinxincludegraphics[width=0.26458in,height=0.26458in]{{image83}.png}
&
Создать новый
начальный шаг
&
Вызов диалога
редактирования шага
\\
\hline
\sphinxincludegraphics[width=0.26458in,height=0.26458in]{{image84}.png}
&
Создать новый шаг
&
Вызов диалога
редактирования шага
\\
\hline
\sphinxincludegraphics[width=0.26458in,height=0.26458in]{{image85}.png}
&
Создать новый переход
&
Вызов диалога
редактирования
перехода
\\
\hline
\sphinxincludegraphics[width=0.26458in,height=0.26458in]{{image86}.png}
&
Создать новый блок
действий
&
Вызов диалога
редактирования блока
действий
\\
\hline
\sphinxincludegraphics[width=0.26458in,height=0.26458in]{{image87}.png}
&
Создать новое
ветвление
&
Вызов диалога
создания новой
дивергенции и
конвергенции
\\
\hline
\sphinxincludegraphics[width=0.26458in,height=0.26458in]{{image88}.png}
&
Создать новый
безусловный переход
&
Вызов диалога
создания «прыжка»
\\
\hline\end{tabulary}


Далее даётся описание добавления приведённых в таблице 8 элементов языка
SFC.

Добавление шага инициализации и шага

Процедура добавления шага инициализации и обычного шага ничем не
отличается. В обоих случаях вызывается диалог «Редактировать шаг» (см.
\hyperref[usage_guide/ide_components:image89]{Рисунок \ref{usage_guide/ide_components:image89} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.91111in,height=1.92917in]{{image90}.png}
\caption{- Диалог редактирования шага инициализации SFC диаграммы}\label{usage_guide/ide_components:image90}\end{figure}

Согласно стандарту IEC 61131-3, на SFC диаграмме должен быть один шаг
инициализации, который характеризует начальное состояние SFC-диаграммы и
отображается со сдвоенными линиями на границах (см. \hyperref[usage_guide/ide_components:image91]{Рисунок \ref{usage_guide/ide_components:image91} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.85429in,height=0.6876in]{{image911}.png}
\caption{- Шаг инициализации языка SFC}\label{usage_guide/ide_components:image91}\end{figure}

В случае, если при добавлении шага не указано его имя - будет выдана
ошибка (см. \hyperref[usage_guide/ide_components:image92]{Рисунок \ref{usage_guide/ide_components:image92} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.12544in,height=1.58355in]{{image92}.png}
\caption{– Ошибка отсутствия имени шага при его добавлении в диаграмму}\label{usage_guide/ide_components:image92}\end{figure}

При добавлении шага появляется диалог, в котором можно указать, с
помощью галочек его соединители (см. \hyperref[usage_guide/ide_components:image89]{Рисунок \ref{usage_guide/ide_components:image89} }):
\begin{itemize}
\item {} 
«Вход»;

\item {} 
«Выход»;

\item {} 
«Действие».

\end{itemize}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.91111in,height=1.92917in]{{image89}.png}
\caption{– Добавление шага SFC на диаграмму}\label{usage_guide/ide_components:image89}\end{figure}

«Действие» добавляет соединитель для связывания данного шага с блоком
действий. «Вход» и «Выход» соединители, как правило, соединены с
переходом. Соответственно, после нажатия кнопки OK, на диаграмму будет
добавлен шаг с указанными соединителями (см. \hyperref[usage_guide/ide_components:image93]{Рисунок \ref{usage_guide/ide_components:image93} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.77394in,height=0.54862in]{{image93}.png}
\caption{- Шаг SFC диаграммы с соединителями входа и действия}\label{usage_guide/ide_components:image93}\end{figure}

Добавление перехода

При добавлении на SFC диаграмму перехода, появится диалог «Редактировать
переход» (см. \hyperref[usage_guide/ide_components:image94]{Рисунок \ref{usage_guide/ide_components:image94} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.66597in,height=2.53125in]{{image94}.png}
\caption{– Добавление нового перехода в диаграмму}\label{usage_guide/ide_components:image94}\end{figure}

В данном диалоге необходимо выбрать тип перехода и его приоритет. Тип
перехода может быть:
\begin{itemize}
\item {} 
«Ссылка»;

\item {} 
«Встроенный код»;

\item {} 
«Соединение».

\end{itemize}

При выборе типа перехода «Ссылка» в открывающемся списке (см. \hyperref[usage_guide/ide_components:image95]{Рисунок \ref{usage_guide/ide_components:image95} })
будут доступны переходы, предопределённые в дереве проекта для данного
программного модуля, написанного на языке SFC. Добавление
предопределённого перехода описывается ниже после описания всех
добавляемых элементов языка SFC.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.71865in,height=2.57843in]{{image95}.png}
\caption{- Всплывающий список с доступными предопределёнными переходами}\label{usage_guide/ide_components:image95}\end{figure}

При выборе типа перехода «Непосредственно» (см. \hyperref[usage_guide/ide_components:image96]{Рисунок \ref{usage_guide/ide_components:image96} }), условие
перехода можно написать в виде выражения на языке ST.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.65625in,height=2.54097in]{{image96}.png}
\caption{- Условие перехода в виде встроенного кода, написанного на языке ST}\label{usage_guide/ide_components:image96}\end{figure}

Реализация перехода таким способом удобна в случае, когда необходимо
короткое условие, например: переменные «F3» и «F4» типа INT равны.
Встроенный код для такого условия выглядит следующим образом (см. \hyperref[usage_guide/ide_components:image96]{Рисунок \ref{usage_guide/ide_components:image96} }):

F3 = F4

Так же например можно в качестве условия просто указать переменную. В
случае её значения равного 0 - будет означать FALSE, все остальные
значения - TRUE.

При выборе типа перехода «Соединение» (см. \hyperref[usage_guide/ide_components:image97]{Рисунок \ref{usage_guide/ide_components:image97} }), в качестве условия
перехода можно использовать выходные значения элементов языка FBD или
LD.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.71667in,height=2.60764in]{{image97}.png}
\caption{- Выбор условия перехода как соединение с элементами других графических языков IEC 61131-3}\label{usage_guide/ide_components:image97}\end{figure}

При выборе типа перехода «Подключение», у добавленного перехода появится
слева контакт, который необходимо соединить с выходным значением,
например, функционального блока языка FBD или катушки LD диаграммы.
Стоит отметить, что данное выходное значение должно быть типа BOOL.
Ниже, на \hyperref[usage_guide/ide_components:image98]{Рисунок \ref{usage_guide/ide_components:image98} } красным цветом выделен пример перехода, условия
которого задано с помощью языка LD.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.88859in,height=1.52941in]{{image98}.png}
\caption{– Пример SFC диаграммы, в которой один из переходов задан с помощью языка LD}\label{usage_guide/ide_components:image98}\end{figure}

Добавление блока действий

При добавлении блока действий на диаграмму появится диалог
«Редактировать свойство блока действий» (см. \hyperref[usage_guide/ide_components:image99]{Рисунок \ref{usage_guide/ide_components:image99} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.70588in,height=2.11019in]{{image99}.png}
\caption{- Диалог «Редактировать свойство блока действий»}\label{usage_guide/ide_components:image99}\end{figure}

Данный блок действий может содержать набор действий. Добавить новое
действие можно нажав кнопку «Добавить» и установив необходимые
параметры:
\begin{itemize}
\item {} 
«Спецификатор»;

\item {} 
«Длительность»;

\item {} 
«Тип»: «Действие», «Переменная», «Непосредственно»;

\item {} 
«Значение»;

\item {} 
«Индикатор».

\end{itemize}

Поле «Спецификатор» определяет момент времени, когда действие
начинается, сколько времени продолжается и когда заканчивается. Выбрать
квалификатор можно из списка (см. \hyperref[usage_guide/ide_components:image100]{Рисунок \ref{usage_guide/ide_components:image100} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.52941in,height=3.41013in]{{image100}.png}
\caption{- Меню выбора спецификатора для действия в диаграмме SFC}\label{usage_guide/ide_components:image100}\end{figure}

Подробное описание спецификаторов, которые выбираются из предлагаемого
списка при добавлении действия приведено в таблице 9.

Таблица 9 - Квалификаторы действий SFC диаграммы

\noindent\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Имя спецификатора
\unskip}\relax &\textsf{\relax 
Поведение блока действия
\unskip}\relax \\
\hline
D
&
Действие начинает выполняться
через некоторое заданное время
(если шаг еще активен) и
выполняется до тех пор, пока
данный шаг активен
\\
\hline
L
&
Действие выполняется в течение
некоторого заданного интервала
времени, после чего выполнение
действия останавливается
\\
\hline
N
&
Действие выполняется, пока данный
шаг активен
\\
\hline
P
&
Действие выполняется один раз,
как только шаг стал активен
\\
\hline
P0
&
Действие выполняется один раз,
как только шаг стал неактивен
\\
\hline
P1
&
Действие выполняется один раз,
как только шаг стал активен
\\
\hline
S
&
Действие активируется и остается
активным пока SFC диаграмма
выполняется
\\
\hline
R
&
Действие выполняется, когда
диаграмма деактивизируется
\\
\hline
DS
&
Действие начинается выполняться
через некоторое заданное время,
только в том случае если шаг еще
активен
\\
\hline
SL
&
Действие активно в течении
некоторого, заданного интервала
\\
\hline
SD
&
Действие начинается выполняться
через некоторое время, даже в том
случае если шаг уже не активен
\\
\hline\end{tabulary}


Поле «Длительность» необходимо для установки интервала времени
необходимого для некоторых квалификаторов, описанных выше в таблице 9.

«Тип» определяет код или конкретную манипуляцию, которая будет
выполняться во время активации действия. В случае выбора «Действия»
появляется возможность, как и в случае с переходом, использовать
предопределённые действия в дереве проекта для данного программного
модуля, написанного на языке SFC (см. \hyperref[usage_guide/ide_components:image101]{Рисунок \ref{usage_guide/ide_components:image101} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.7451in,height=2.14006in]{{image1011}.png}
\caption{- Выбор предопределённого действия}\label{usage_guide/ide_components:image101}\end{figure}

Добавление предопределённого действия также как добавление
предопределённого перехода описывается ниже после описания всех
добавляемых элементов языка SFC.

В случае выбора типа действия «Переменная» в поле «Значение» появляется
возможность выбрать переменные (см. \hyperref[usage_guide/ide_components:image102]{Рисунок \ref{usage_guide/ide_components:image102} }), относящиеся к данному
программному модулю.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.68611in,height=2.00972in]{{image102}.png}
\caption{- Выбор предопределённой переменной}\label{usage_guide/ide_components:image102}\end{figure}

Как только шаг становится активным, данная переменная в зависимости от
своего типа принимает значение 0, 0.0, FALSE и другие нулевые значения
типов. Как только действие начинает выполняться, переменная принимает
значение 1, 1.0, TRUE и другие единичные значения типов. В случае если
действие прекратило своё выполнение переменная снова принимает значение
0, 0.0, FALSE и другое нулевое значение, в зависимости от своего типа.

В случае выбора «Непосредственно», появляется возможность в поле
«Значение» написать на языке ST код, который будет выполняться, когда
действие становится активным (см. \hyperref[usage_guide/ide_components:image103]{Рисунок \ref{usage_guide/ide_components:image103} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.83333in,height=2.14861in]{{image103}.png}
\caption{- Написание встроенного кода для действия}\label{usage_guide/ide_components:image103}\end{figure}

Следует отметить, что в конце встроенного кода для действия необходимо
поставить «;», в отличие от встроенного кода для перехода.

После добавления блока действия на диаграмму необходимо его
ассоциировать с конкретным шагом. Данная операция выполняется обычным
соединением правого контакта у шага и левого контакта у действия (см.
\hyperref[usage_guide/ide_components:image104]{Рисунок \ref{usage_guide/ide_components:image104} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.16279in,height=1.11494in]{{image104}.png}
\caption{- Ассоциирование шага ORANGE блоком действия, содержащим четыре действия}\label{usage_guide/ide_components:image104}\end{figure}

Добавление дивергенции и конвергенции

При добавлении ветвления, появится диалог «Создать новое ветвление» (см.
\hyperref[usage_guide/ide_components:image105]{Рисунок \ref{usage_guide/ide_components:image105} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.66667in,height=2.08786in]{{image105}.png}
\caption{– Добавление альтернативного ветвления(дивергенции)}\label{usage_guide/ide_components:image105}\end{figure}

В первую очередь следует выбрать тип ветвления:
\begin{itemize}
\item {} 
«Альтернативное ветвление»;

\item {} 
«Альтернативное объединения»;

\item {} 
«Параллельное ветвление»;

\item {} 
«Параллельное объединение».

\end{itemize}

Вторым параметром является количество разветвлений, которое определяет
на сколько ветвей будет либо расходится (в случае выбора типа
дивергенции «Альтернативное ветвление» или «Параллельное ветвление»)
одна ветвь, либо сколько ветвей будет сходиться в одну ветвь (в случае
выбора типа дивергенции «Альтернативное объединения» или «Параллельное
объединение»)

Пример дивергенции с двумя разветвлениями показан на \hyperref[usage_guide/ide_components:image106]{Рисунок \ref{usage_guide/ide_components:image106} } и выделен
красным цветом.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.9186in,height=2.27907in]{{image106}.png}
\caption{– Пример SFC диаграммы, содержащей альтернативное ветвление}\label{usage_guide/ide_components:image106}\end{figure}

Пример конвергенции выделен красным цветом на \hyperref[usage_guide/ide_components:image106-2]{Рисунок \ref{usage_guide/ide_components:image106-2} }.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.39216in,height=2.19608in]{{image106}.png}
\caption{– Пример SFC диаграммы, содержащей альтернативное объединение}\label{usage_guide/ide_components:image106-2}\end{figure}

Пример параллельного ветвления показан на \hyperref[usage_guide/ide_components:image107]{Рисунок \ref{usage_guide/ide_components:image107} } и выделен красным
цветом.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.87255in,height=2.31373in]{{image107}.png}
\caption{– Пример SFC диаграммы с параллельным ветвлением}\label{usage_guide/ide_components:image107}\end{figure}

Согласно стандарту IEC 61131-3, каждая ветвь альтернативного ветвления
должна оканчиваться переходом, при альтернативном объединении переход
должен быть перед каждой ветвью. При параллельном ветвлении переход
должен быть перед ветвлением, а при параллельном объединении переход
необходим после объединения.

Добавление безусловного перехода

Элемент «безусловный переход» на SFC диаграмме подобен выполнению
оператора GOTO при переходе на определённую метку в коде в различных
языках программирования. После выбора добавления «прыжка» на SFC
диаграмму, появится диалог (см. \hyperref[usage_guide/ide_components:image108]{Рисунок \ref{usage_guide/ide_components:image108} }), в котором необходимо выбрать
из списка шаг, к которому будет происходить «прыжок» - переход от одного
шага SFC диаграммы к другому.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.54214in,height=1.94792in]{{image108}.png}
\caption{– Диалог добавления безусловного перехода}\label{usage_guide/ide_components:image108}\end{figure}

В данном диалоге также присутствует и шаг инициализации (начальный шаг).
После выбора шага и нажатия кнопки OK. На SFC диаграмме появится
стрелочка, которую нужно соединить с переходом (см. \hyperref[usage_guide/ide_components:image109]{Рисунок \ref{usage_guide/ide_components:image109} }). Справа от
стрелочки находится имя шага, к которому осуществляется переход в случае
выполнения условия перехода, находящегося выше и соединённого с ней.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.95278in,height=2.725in]{{image109}.png}
\caption{– Безусловный переход с шага Stop на начальный шаг Start}\label{usage_guide/ide_components:image109}\end{figure}

Согласно стандарту IEC 61131-3, между шагом и «прыжком» должен
обязательно быть определён переход.

Предопределённые условия перехода и действия в дереве проекта

В случае, если необходимо использовать определённое условие перехода
между множеством шагов, есть возможность определить данное условие
перехода в структуре SFC диаграммы. Данная операция выполняется нажатием
на данную SFC диаграмму на дереве проекта правой клавишей мыши
и выбором «Добавить переход» (см. \hyperref[usage_guide/ide_components:image110]{Рисунок \ref{usage_guide/ide_components:image110} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.63681in,height=2.62431in]{{image110}.png}
\caption{- Всплывающее меню SFC диаграммы в панели проекта}\label{usage_guide/ide_components:image110}\end{figure}

Далее появится диалог под названием «Создать новый переход» (см.:numref:\sphinxtitleref{image111}).
В нём необходимо выбрать уникальное имя перехода и язык, в котором
будет описано данное условие.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.03889in,height=1.60694in]{{image1111}.png}
\caption{- Диалог «Создать новый переход»}\label{usage_guide/ide_components:image111}\end{figure}

В случае, если переходы с введённым именем уже существуют, то будет
выведено сообщение об ошибке (см. \hyperref[usage_guide/ide_components:image112]{Рисунок \ref{usage_guide/ide_components:image112} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.93103in,height=1.26593in]{{image112}.png}
\caption{- Сообщение об ошибке добавления существующего программного модуля}\label{usage_guide/ide_components:image112}\end{figure}

Добавление действия в структуру SFC диаграммы (см. \hyperref[usage_guide/ide_components:image113]{Рисунок \ref{usage_guide/ide_components:image113} }) происходит
аналогично добавлению перехода в данную структуру.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.25862in,height=1.81131in]{{image113}.png}
\caption{- Всплывающее меню SFC для структуры диаграммы}\label{usage_guide/ide_components:image113}\end{figure}

После выбора «Добавить действие» во всплывающем меню, вызванном с
помощью нажатия правой клавиши мыши по программному модулю, написанном с
помощью языка SFC, появится диалог «Создать новое действие»
(см. \hyperref[usage_guide/ide_components:image114]{Рисунок \ref{usage_guide/ide_components:image114} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.48958in,height=1.42039in]{{image114}.png}
\caption{- Диалог «Создать новое действие»}\label{usage_guide/ide_components:image114}\end{figure}

В данном диалоге необходимо указать «Имя действия» (должно быть
уникальным) и выбрать язык (ST, IL, FBD, LD), на котором будет написано
данное действие. Если имя действия не заполнено будет выведено сообщение
об ошибке (см. \hyperref[usage_guide/ide_components:image115]{Рисунок \ref{usage_guide/ide_components:image115} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.125in,height=1.23355in]{{image115}.png}
\caption{- Ошибка не заполнения имени действия при его добавлении}\label{usage_guide/ide_components:image115}\end{figure}

После того как действие добавлено, необходимо реализовать его код на
текстовом или графическом языке, в зависимости от языка, который был
выбран в диалоге «Создать новое действие» (см. \hyperref[usage_guide/ide_components:image114]{Рисунок \ref{usage_guide/ide_components:image114} }). После
добавления переходов и действий в дерево проекта они будут доступны для
множественного использования.

Описание языка SFC, основных конструкций и примера его использования
приведены в приложении 7.


\subsubsection{Панель редактирования ресурса}
\label{usage_guide/ide_components:id6}
Панель редактирования ресурса (см. \hyperref[usage_guide/ide_components:image116]{Рисунок \ref{usage_guide/ide_components:image116} }) содержит панель переменных и
констант, которая позволяет определять глобальные переменные на уровне
ресурса и панели, содержащие задачи и экземпляры.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.56815in,height=4.17708in]{{image116}.png}
\caption{- Вкладка ресурс главной рабочей области}\label{usage_guide/ide_components:image116}\end{figure}

Добавление переменных в ресурс ничем не отличается от добавления
переменных в программные модули, единственное исключение - переменные
могут быть только класса «Глобальная». Основной задачей данной панели
является возможность добавить экземпляр, указать для него программный
модуль типа «Программа», из ранее определённых в проекте, для поля «Тип»
и выбрать задачу из добавленных в список «Задачи».


\subsubsection{Панель редактирования типа данных}
\label{usage_guide/ide_components:id7}
Панель редактирования типа данных (см. \hyperref[usage_guide/ide_components:image117]{Рисунок \ref{usage_guide/ide_components:image117} }) позволяет определить
различные параметры создаваемого пользовательского типа данных.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.3125in,height=2.10947in]{{image117}.png}
\caption{- Вкладка создания нового типа данных}\label{usage_guide/ide_components:image117}\end{figure}

Главным параметром является список под названием «Механизм создания
нового типа», позволяющим выбрать следующие типы:
\begin{itemize}
\item {} 
Синоним;

\item {} 
Поддиапазон существующего типа (выделение диапазона значений
стандартного типа);

\item {} 
Перечисление (перечисляемый тип);

\item {} 
Массив;

\item {} 
Структура, позволяющая определять тип, основанный на объединении
несколько типов.

\end{itemize}

Далее рассмотрены подробнее параметры для каждого из вышеперечисленных
типов.

Синоним

При выборе «Синоним» (см. \hyperref[usage_guide/ide_components:image118]{Рисунок \ref{usage_guide/ide_components:image118} }), из списка указывается базовый тип и
его начальное значение.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.38542in,height=1.48496in]{{image118}.png}
\caption{- Добавление псевдонима типа данных}\label{usage_guide/ide_components:image118}\end{figure}

Созданный тип представляет собой псевдоним (например, аналогично
использованию typedef в языке C) уже существующего типа.

Поддиапазон существующего типа

В случае выбора механизма создания нового типа «Поддиапазон
существующего типа», помимо базового типа и начального значения
производится установка параметров «Минимум» и «Максимум» (см. \hyperref[usage_guide/ide_components:image119]{Рисунок \ref{usage_guide/ide_components:image119} }),
т.е. соответственно минимального и максимального значения, которое может
принимать создаваемый тип данных.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.28125in,height=2.08966in]{{image119}.png}
\caption{- Добавление нового типа данных, представляющего поддиапазон существующего типа}\label{usage_guide/ide_components:image119}\end{figure}

Перечисляемый тип

При выборе механизма создания нового типа «Перечисляемый тип»
(см. \hyperref[usage_guide/ide_components:image120]{Рисунок \ref{usage_guide/ide_components:image120} }), появится панель,
содержащая таблицу, в которой можно задать список
возможных значений данного перечисляемого типа.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.13542in,height=2.99656in]{{image120}.png}
\caption{– Добавление перечисляемого типа данных}\label{usage_guide/ide_components:image120}\end{figure}

Добавление, редактирование, удаление, перемещение данных значений
осуществляется с помощью кнопок, описание которых приведено в таблице 10

Таблица 10 - Кнопки редактирования значений перечисляемого типа

\noindent\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Внешний вид кнопки
\unskip}\relax &\textsf{\relax 
Название кнопки
\unskip}\relax &\textsf{\relax 
Функция кнопки
\unskip}\relax \\
\hline
\sphinxincludegraphics[width=0.29167in,height=0.29167in]{{image121}.png}
&
Редактировать
&
Редактировать
выделенное поле в
таблице
\\
\hline
\sphinxincludegraphics[width=0.27778in,height=0.27761in]{{image121_1}.png}
&
Добавить
&
Добавить новое поле в
таблицу
\\
\hline
\sphinxincludegraphics[width=0.27083in,height=0.27753in]{{image121_2}.png}
&
Удалить
&
Удалить выделенное
поле в таблице
\\
\hline
\sphinxincludegraphics[width=0.27083in,height=0.27778in]{{image121_3}.png}
&
Переместить вверх
&
Переместить вверх
выделенное поле в
таблице
\\
\hline
\sphinxincludegraphics[width=0.28403in,height=0.2771in]{{image121_4}.png}
&
Переместить вниз
&
Переместить вниз
выделенное поле в
таблице
\\
\hline\end{tabulary}


Также есть возможность задать начальное значение данного перечисляемого
типа в поле «Начальное значение».

Массив

При выборе механизма создания нового типа «Массив» (см. \hyperref[usage_guide/ide_components:image122]{Рисунок \ref{usage_guide/ide_components:image122} })
появится панель, в которой необходимо указать базовый тип, начальное
значение, а также размерность массива.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.61769in,height=2.71875in]{{image122}.png}
\caption{- Добавление типа данных - массива}\label{usage_guide/ide_components:image122}\end{figure}

Размерность массива задаётся в следующем формате: \textless{}начальное
значение\textgreater{}..\textless{}конечное значение\textgreater{}

Структура

При выборе механизма создания нового типа «Структура» (см. \hyperref[usage_guide/ide_components:image123]{Рисунок \ref{usage_guide/ide_components:image123} }), в
появившейся таблице необходимо добавить необходимое количество полей
структуры. Каждое поле имеет своё имя, тип и начальное значение.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.06191in,height=2.48194in]{{image123}.png}
\caption{– Добавление типа данных – структура}\label{usage_guide/ide_components:image123}\end{figure}

Добавленные типы данных могут использоваться также как и стандартные при
реализации алгоритмов и логики выполнения программных модулей.

Выше были рассмотрены варианты редактирования различных элементов, из
которых состоит проект, согласно стандарту IEC 61131-3. Далее будет
продолжено рассмотрение остальных компонент среды разработки Beremiz.


\subsubsection{Панель экземпляров проекта}
\label{usage_guide/ide_components:id8}
Панель экземпляров проекта (см. \hyperref[usage_guide/ide_components:image124]{Рисунок \ref{usage_guide/ide_components:image124} }) обычно располагается слева в
среде разработки Beremiz и отображаемые в ней экземпляры зависят от
выбранного элемента в дереве проекта.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.24386in,height=3.44776in]{{image124}.png}
\caption{– Панель экземпляров проекта}\label{usage_guide/ide_components:image124}\end{figure}

При выборе в дереве проекта элемента, соответствующего ресурсу, в панели
экземпляров проекта будут отображены экземпляры,
определённые в данном ресурсе, а так же глобальные переменные ресурса.
На \hyperref[usage_guide/ide_components:image125]{Рисунок \ref{usage_guide/ide_components:image125} } показано, как в панели редактирования ресурса определен
экземпляр для программного модуля «main\_program»:
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.40556in,height=3.07361in]{{image125}.png}
\caption{– Экземпляр main\_instance для программного модуля main\_program}\label{usage_guide/ide_components:image125}\end{figure}

Соответственно, при выборе в дереве проекта ресурса, в котором
определены экземпляры (описанные выше) и глобальная переменная, панель
экземпляров будет выглядеть, как показано на \hyperref[usage_guide/ide_components:image126]{Рисунок \ref{usage_guide/ide_components:image126} }:
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.01042in,height=1.17988in]{{image126}.png}
\caption{- Панель экземпляров при выборе элемента ресурса в дереве проекта}\label{usage_guide/ide_components:image126}\end{figure}

При выборе в дереве проекта элемента, соответствующего программным
модулям «Программа» и «Функциональный блок» в панели экземпляров будут
отображены переменные, определённые в них. Ниже на \hyperref[usage_guide/ide_components:image127]{Рисунок \ref{usage_guide/ide_components:image127} } приведён
пример программного модуля типа «Программа» с именем «program0», в
котором определено 8 переменных различных пользовательских классов.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.91896in,height=2.75978in]{{image127}.png}
\caption{- Программный модуль типа «Программа»}\label{usage_guide/ide_components:image127}\end{figure}

Соответственно, при выборе в дереве проекта данного программного модуля
в панели экземпляров будут отображены, определённые выше переменные
(см. \hyperref[usage_guide/ide_components:image128]{Рисунок \ref{usage_guide/ide_components:image128} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.49844in,height=2.23864in]{{image128}.png}
\caption{- Панель экземпляров проекта при выборе в дереве проекта программного модуля main\_program}\label{usage_guide/ide_components:image128}\end{figure}

В случае выбора других элементов в дереве проекта, панель отладки будет
пустой. Как можно заметить, с правой стороны от каждого элемента в
панели отладки располагаются кнопки, назначение которых описано в
таблице 11.

Таблица 11 - Кнопки на панели экземпляров проекта

\noindent\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Внешний вид кнопки
\unskip}\relax &\textsf{\relax 
Название кнопки
\unskip}\relax &\textsf{\relax 
Функция кнопки
\unskip}\relax \\
\hline
\sphinxincludegraphics[width=0.26875in,height=0.26875in]{{image129}.png}
&
Отладка экземпляра
&
Кнопка запуска режима
отладки для
экземпляра
\\
\hline
\sphinxincludegraphics[width=0.26654in,height=0.26654in]{{image129}.png}
&
Двойной щелчок по
кнопке «Отладка
экземпляра»
&
Отображение графика
изменения значения
переменной в режиме
отладки
\\
\hline
\sphinxincludegraphics[width=0.26654in,height=0.26654in]{{image130}.png}
&
Родительский
экземпляр
&
Переход к
родительскому
экземпляру и его
локальным переменным
\\
\hline\end{tabulary}


В случае нажатия кнопки запуска режима отладки, для экземпляра
программы, написанной на одном из графических языков (FBD, LD или SFC),
откроется вкладка с панелью, на которой диаграмма будет отображена в
режиме отладки. Если кнопка запуска режима отладки нажимается
для элемента переменной, то переменная будет добавлена в панель отладки.

Описанные выше кнопки доступны только в режиме отладки прикладной
программы. Про данный режим подробнее рассказывается в п. 8.


\subsubsection{Панель библиотеки функций и функциональных блоков}
\label{usage_guide/ide_components:id9}
Панель библиотеки функций и функциональных блоков (см. \hyperref[usage_guide/ide_components:image131]{Рисунок \ref{usage_guide/ide_components:image131} }), как
правило, располагается справа в среде разработки Beremiz. Она содержит
коллекцию стандартных функций и функциональных блоков, разделённых по
разделам в соответствии с их назначением, которые доступны при написании
алгоритмов и логики работы программных модулей.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.83582in,height=4.78215in]{{image131}.png}
\caption{– Панель библиотеки функций и функциональных блоков}\label{usage_guide/ide_components:image131}\end{figure}

Выделены следующие разделы для функций и функциональных блоков:
стандартные, дополнительные, преобразования типов данных, операций с
числовыми данными, арифметических операций, временных операций,
побитовых и смещения бит, операций выбора, операций сравнения, строковых
операций, модулей «Python» и «SVGUI».

Помимо стандартных функций и функциональных блоков, данная панель
содержит раздел «пользовательские программные модули». В него попадают
функции и функциональные блоки, добавленные в конкретный проект, т. е.
содержащиеся в дереве проекта.

Использование данных функций и функциональных блоков осуществляется
перетаскиванием необходимого блока с помощью зажатой левой кнопки мыши
(Drag\&Drop) в область редактирования: либо текстовый редактор, либо
графический редактор.Имеется специальное поле поиска
функционального блока по имени.


\subsubsection{Отладочная консоль}
\label{usage_guide/ide_components:id10}
Панель, содержащая отладочную консоль (см. \hyperref[usage_guide/ide_components:image132]{Рисунок \ref{usage_guide/ide_components:image132} }), как правило,
располагается в правом нижнем углу среды разработки Beremiz.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.21844in,height=2.31343in]{{image132}.png}
\caption{– Успешная сборка в отладочной консоли}\label{usage_guide/ide_components:image132}\end{figure}

Она служит для отображения в виде текстовых сообщений:
\begin{itemize}
\item {} 
Результатов генерации ST и C кода;

\item {} 
Результатов компиляции и компоновки прикладной программы;

\item {} 
Процесса соединения и передачи прикладной программы на целевое
устройство;

\item {} 
Различных промежуточных манипуляций в процессы создания прикладной
программы.

\end{itemize}

В случае, если необходимо вывести предупреждения среды разработки
Beremiz или ошибки компиляторов (MatlEC или C кода) во время их работы
цвет вывода текстовых сообщений становится красным. Критические ошибки
также выделяется красным цветом, но при этом еще желтым фоном (см. \hyperref[usage_guide/ide_components:image133]{Рисунок \ref{usage_guide/ide_components:image133} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.3125in,height=2.31319in]{{image133}.png}
\caption{- Ошибка сборки проекта в отладочной консоли}\label{usage_guide/ide_components:image133}\end{figure}


\subsubsection{Поиск элементов в проекте}
\label{usage_guide/ide_components:id11}
Для поиска интересующего элемента в проекте используется диалог «Поиск в
проекте» (см. \hyperref[usage_guide/ide_components:image134]{Рисунок \ref{usage_guide/ide_components:image134} }). Его вызов происходит с помощью главного меню
программы или панели инструментов.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.14861in,height=2.87083in]{{image134}.png}
\caption{– Диалог поиска в проекте}\label{usage_guide/ide_components:image134}\end{figure}

В появившемся диалоге можно установить различные параметры поиска:
шаблон поиска, область поиска, чувствительность к регистру при поиске, а
так же записать шаблон поиска в виде регулярного выражения. После того
как все параметры установлены, необходимо нажать кнопку «Поиск» в этом
диалоге. Ниже на \hyperref[usage_guide/ide_components:image135]{Рисунок \ref{usage_guide/ide_components:image135} } приведен пример поиска элемента с именем
«LIGHT».
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.17847in,height=5.52292in]{{image135}.png}
\caption{– Результаты поиска элемента с именем LIGHT}\label{usage_guide/ide_components:image135}\end{figure}

Результат поиска выводится в иерархической структуре. При двойном щелчке
по одному из результатов - данный элемент будет выделен в проекте
оранжевым цветом.


\subsubsection{Панель отладки}
\label{usage_guide/ide_components:id12}
Панель отладки располагается в правой части среды разработки Beremiz
(см. \hyperref[usage_guide/ide_components:image136]{Рисунок \ref{usage_guide/ide_components:image136} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.45833in,height=1.81181in]{{image136}.png}
\caption{– Панель отладки}\label{usage_guide/ide_components:image136}\end{figure}

Данная панель представляет собой таблицу с двумя столбцами «Переменная»
и «Значение». Соответственно, столбец «Переменная» содержит экземпляры
переменных, значения которых во время исполнения, отображаются в поле
«Значение» и могут изменяться. Добавление переменных осуществляется с
помощью панели экземпляров проекта.

Изменение значений переменной во время отладки прикладной программы
осуществляется нажатием левой клавишей мыши на иконку замка напротив
интересующей переменной (см. \hyperref[usage_guide/ide_components:image137]{Рисунок \ref{usage_guide/ide_components:image137} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.42708in,height=1.86875in]{{image137}.png}
\caption{– Установка значения переменной}\label{usage_guide/ide_components:image137}\end{figure}

Далее появится диалог ввода значения для выбранной переменной (см. \hyperref[usage_guide/ide_components:image138]{Рисунок \ref{usage_guide/ide_components:image138} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.97083in,height=1.48958in]{{image138}.png}
\caption{– Диалог установки значения для переменной}\label{usage_guide/ide_components:image138}\end{figure}

В режиме отладки форсированное значение переменной будет подсвечено
синим цветом. Для того чтобы освободить значение переменной, необходимо
нажать на иконку открытого замка (см. \hyperref[usage_guide/ide_components:image139]{Рисунок \ref{usage_guide/ide_components:image139} })
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.0625in,height=1.71944in]{{image139}.png}
\caption{– Освобождение значения переменной}\label{usage_guide/ide_components:image139}\end{figure}

На данной панели присутствует кнопка удаления переменной из панели
отладчика, перемещать и передавать ссылку на переменные можно в
Drag\&Drop режиме.


\subsubsection{Панель графика изменения значения переменной в режиме отладки}
\label{usage_guide/ide_components:id13}
Данная панель (см. \hyperref[usage_guide/ide_components:image140]{Рисунок \ref{usage_guide/ide_components:image140} }) открывается во вкладке отладчика напротив
выбранной переменной в случае, если в панели отладчика
нажать на переменную двойным щелчком мыши. Напротив переменной
появляется график изменения значения переменной в режиме отладки (см.
таблицу 11).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.06181in,height=4.80972in]{{image140}.png}
\caption{– Графики изменения значений счетчиков Cnt}\label{usage_guide/ide_components:image140}\end{figure}

На данной панели есть возможность установить:
\begin{itemize}
\item {} 
«Интервал» - временной отрезок, за который отображается изменений
графика;

\item {} 
«Масштаб» - задание приближения отображения графика;

\item {} 
«Позиция» - перемещение по отображению графика, от начала и до конца.

\end{itemize}

Также на данной панели в правом нижнем углу располагаются
вспомогательные кнопки. Описание данных кнопок приведено в таблице 12:

Таблица 12 - Кнопки на панели графика изменения значения переменной

\noindent\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Внешний вид кнопки
\unskip}\relax &\textsf{\relax 
Функция кнопки
\unskip}\relax \\
\hline
\sphinxincludegraphics[width=0.26736in,height=0.26736in]{{image141}.png}
&
Очистка отображения графика
\\
\hline
\sphinxincludegraphics[width=0.26736in,height=0.26736in]{{image142}.png}
&
Переход к отображению текущего
значения графика, т.е. сдвиг
параметра «Позиция» максимально
вправо
\\
\hline
\sphinxincludegraphics[width=0.17431in,height=0.17431in]{{image143}.png}
&
Сброс настроек масштаба до
настроек по умолчанию: x 1.0
\\
\hline\end{tabulary}



\subsection{Работа с проектом}
\label{usage_guide/work_with_project::doc}\label{usage_guide/work_with_project:id1}
Данный раздел отражает основные приемы работы в среде разработки
Beremiz, необходимые при создании прикладной программы. Прикладная
программа для целевой платформы является результатом сборки проекта с
определенной конфигурацией.

Проект в Beremiz представляет собой именованную папку, в которой лежат
исходные файлы. Папка должна быть обязательно пустой и не защищена от
записи. Если в папке уже есть файлы, будет выдана соответствующая
ошибка. В созданной папке будут сохранены следующие файлы и папки:
\begin{itemize}
\item {} 
«beremiz.xml» – в данном XML файле сохраняются настройки специфичные
для среды разработки Beremiz относительно проекта;

\item {} 
«plc.xml» – в данном XML файле сохраняется полное описание проекта:
всех программных модулей, ресурсов, пользовательских типов данных,
данных о проекте, настроек редакторов графических языков IEC 61131-3;

\item {} 
папка «build», которая хранит генерируемый ST и C код, а также
получаемый исполняемый бинарный файл прошивки.

\end{itemize}


\subsubsection{Создание нового проекта}
\label{usage_guide/work_with_project:id2}
Новый проект создаётся с помощью главного меню «Файл» – «Новый»
(см. \hyperref[usage_guide/work_with_project:image144]{Рисунок \ref{usage_guide/work_with_project:image144} }), либо с помощью кнопки «Новый»
на панели управления.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.71875in,height=3.65812in]{{image1441}.png}
\caption{- Создание нового проекта с помощью главного меню}\label{usage_guide/work_with_project:image144}\end{figure}

Далее появится диалог (см. \hyperref[usage_guide/work_with_project:image145]{Рисунок \ref{usage_guide/work_with_project:image145} }) , в котором необходимо выбрать
папку, где будет храниться данный проект.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.55208in,height=3.65973in]{{image145}.png}
\caption{- Диалог выбора папки для нового проекта}\label{usage_guide/work_with_project:image145}\end{figure}

В появившемся диалоге вам будет предложено настроить основной
программный модуль проекта (см. \hyperref[usage_guide/work_with_project:image146]{Рисунок \ref{usage_guide/work_with_project:image146} }). В данном диалоге три поля:
\begin{itemize}
\item {} 
«Имя POU»;

\item {} 
«Тип POU»;

\item {} 
«Язык».

\end{itemize}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.95247in,height=2.80208in]{{image146}.png}
\caption{- Диалог добавления основного программного модуля}\label{usage_guide/work_with_project:image146}\end{figure}

Имя программного модуля, присвоенное по умолчанию, может быть заменено
на любое имя, соответствующее назначению данного программного модуля.

Тип основного программного модуля – «Программа», в дальнейшем в проект
можно добавить дополнительные программные модули, функции и
функциональные блоки.

В поле «Язык» необходимо выбрать из списка один из языков стандарта IEC
61131-3 (IL, ST, LD, FBD, SFC), на котором будут реализованы алгоритмы и
логика работы данного добавляемого программного модуля.

При нажатии кнопки ОК в проект будет добавлен основной программный
модуль с выбранными параметрами, ресурс проекта будет конфигурирован по
умолчанию: добавлена одна задача циклического выполнения с интервалом 20
мс, и один экземпляр основной программы. При нажатии кнопки
Отмена будет создан пустой проект без каких-либо настроек.

В рамках описания процесса создания нового проекта за основу выбран
проект «First steps» из стандартного набора тестовых проектов IDE
Beremiz. Основной программный модуль в этом проекте написан на языке
FBD, соответственно, в диалоге необходимо выбрать язык FBD, в дальнейшем
язык основного программного модуля возможно изменить.


\subsubsection{Настройка проекта}
\label{usage_guide/work_with_project:id3}
Следующим шагом после создания проекта является его настройка,
включающая в себя задание глобальных переменных, установку параметров
компиляции и компоновки, и заполнение данных о проекте.

Вызов панели настройки проекта осуществляется при выборе (двойном щелчке
левой кнопкой мыши) корневого элемента дерева проекта, который по
умолчанию, сразу после создания проекта называется «Unnamed»(см. \hyperref[usage_guide/work_with_project:image147]{Рисунок \ref{usage_guide/work_with_project:image147} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.26597in,height=2.92948in]{{image147}.png}
\caption{- Панель настройки проекта}\label{usage_guide/work_with_project:image147}\end{figure}

На панели присутствуют три вкладки:
\begin{itemize}
\item {} 
Конфигурационные переменные;

\item {} 
Свойства проекта;

\item {} 
Конфигурация.

\end{itemize}


\paragraph{Конфигурационные переменные проекта}
\label{usage_guide/work_with_project:id4}
Конфигурационные переменные позволяют программным модулям типа
«Программа» и «Функциональный блок» использовать общие переменные,
которые будут определены в глобальной области видимости проекта.

Ниже, на \hyperref[usage_guide/work_with_project:image149]{Рисунок \ref{usage_guide/work_with_project:image149} }, в панели переменных и констант добавим
конфигурационную константу «ResetCounterValue» типа INT с начальным
значением 17, с помощью кнопки «Добавить переменную» (см. таблицу 3).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=7.51597in,height=1.92014in]{{image149}.png}
\caption{- Объявление конфигурационной переменной}\label{usage_guide/work_with_project:image149}\end{figure}

Для того чтобы к данной конфигурационной переменной можно было
обращаться из программных модулей типа «Программа» или «Функциональный
блок» необходимо в их панели редактирования в панели переменных и
констант создать переменную с таким же именем, как и ранее объявленная
глобальная, и установить её класс «Внешний».


\paragraph{Настройки сборки проекта и соединения с целевым устройством}
\label{usage_guide/work_with_project:id5}
Для использования написанной прикладной программы необходимо её собрать
(скомпилировать и скомпоновать), т.е. получить исполняемый файл и
передать на целевое устройство для отладки или просто исполнения. В
связи с этим основными настройками являются: «URI системы исполнения» -
адрес целевого устройства, и целевая платформа - архитектура платформы
целевого устройства (см. \hyperref[usage_guide/work_with_project:image150]{Рисунок \ref{usage_guide/work_with_project:image150} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.30208in,height=4.4905in]{{image150}.png}
\caption{- Конфигурация проекта}\label{usage_guide/work_with_project:image150}\end{figure}

Как правило, «URI системы исполнения» указывается в формате:

\textless{}Тип коннектора\textgreater{})://\textless{}Адрес последовательного порта
подключения\textgreater{}:\textless{}битрейт\textgreater{}

Тип коннектора выбирается в зависимости от типа сервиса подключения к
целевому устройству. Например, для отладки прикладной программы на
локальной машине при помощи Soft PLC, целевым устройством является
служба «Beremiz service» и тип коннектора следует выбрать «LOCAL». Для
отладки прикладной программы вне локальной машины используется
библиотека PYRO, в это случае «URI целевого устройства» указывается в
формате:

PYRO://\textless{}IP-адрес целевого устройства\textgreater{}:\textless{}порт\textgreater{}

Если в проекте используются дополнительные библиотеки, их следует
добавить в конфигурации проекта, нажав «checkbox» напротив добавляемой
библиотеки в подменю «Библиотеки».


\paragraph{Данные о проекте}
\label{usage_guide/work_with_project:id6}
При создании нового проекта, все обязательные поля в настройках
информации о проекте заполняются значениями по умолчанию. Рекомендуется
заменить данные настройки по умолчанию на релевантную информацию
(см.:numref:\sphinxtitleref{image152}), позволяющую удобным образом различать проекты.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.70833in,height=3.91046in]{{image152}.png}
\caption{- Заполнение данных о проекте}\label{usage_guide/work_with_project:image152}\end{figure}

Большая часть данных в информации проекте являются необязательным для
заполнения, но обязательные должны быть заполнены, такие поля помечены в
подсказках в именовании каждого пункта. После задания настроек проекта,
как правило, следует добавление в проект необходимых программных модулей
(функций, функциональных блоков и программ), реализация их алгоритмов и
логики работы с помощью текстовых и графических языков стандарта IEC
61131-3.


\subsubsection{Программные модули}
\label{usage_guide/work_with_project:id7}
Добавление программных модулей (программ, функций, функциональных
блоков) осуществляется с помощью всплывающего меню дерева проекта,
в котором необходимо выбрать пункт «Функция», «Функциональный
блок» или «Программа». Далее появится диалог «Создать новый POU».

Проект «First steps» представляет собой основной программный модуль,
написанный на языке FBD, в котором используются 5 функциональных блоков,
написанных на пяти разных языках IEC 61131-3. Каждый функциональный блок
это счетчик, увеличивающий значение выхода на единицу до тех пор, пока
на входе Reset не будет установлено значение True. Инкрементация
значения происходит в каждом цикле основной программы. Регулировать
интервал цикла можно изменяя длительность задачи для экземпляра основной
программы в панели ресурсов.

В созданный проект необходимо добавить программу program0, функцию и 5
функциональных блоков: CounterST, CounterLD, CounterFBD, CounterSFC,
CounterIL. Если при создании проекта основной программный модуль
program0 не был добавлен, его следует добавить вручную. Далее
рассмотрено добавление каждого программного модуля в отдельности.


\paragraph{Программа}
\label{usage_guide/work_with_project:id8}
Ниже будет приведён пример добавления в проект программы, написанной на
языке FBD. Логика и алгоритм работы данного программного модуля
следующие: определена переменная Reset типа BOOL, отвечающая за сброс
каждого из пяти счетчиков, определены пять переменных Cnt1..Cnt5 типа
INT, в них хранится значение каждого из пяти счетчиков, и добавлены пять
функциональных блоков, представляющих собой инкрементирующий счетчик на
пяти языках IEC 61131-3. При запуске программы начальное значение
переменной Reset устанавливается по умолчанию False. Значения счетчиков
начнут увеличиваться, начиная со значения по умолчанию (для типа INT
равно 0). Для сброса счетчиков переменную Reset необходимо форсировать
значением True, затем вернуть значение False. Переменным Cnt1..Cnt5
будет присвоено начальное значение конфигурационной константы
ResetCounterValue, таким образом значения счетчиков
сбросятся, и начнется отсчет начиная с 17.

Сначала следует добавление программы в проект, осуществляемое с помощью
меню дерева проекта, выбором пункта «Программа» (см. \hyperref[usage_guide/work_with_project:image153]{Рисунок \ref{usage_guide/work_with_project:image153} }):
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.48837in,height=3.73256in]{{image153}.png}
\caption{- Добавление программы в проект}\label{usage_guide/work_with_project:image153}\end{figure}

В появившемся диалоге (см. \hyperref[usage_guide/work_with_project:image154]{Рисунок \ref{usage_guide/work_with_project:image154} }) выберем язык FBD и тип POU
«программа».
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.23958in,height=2.46875in]{{image154}.png}
\caption{- Диалог добавления программы в проект}\label{usage_guide/work_with_project:image154}\end{figure}

Добавим в панели переменных и констант переменную Reset типа BOOL,
отвечающую за сброс каждого из пяти счетчиков, а так же пять переменных
Cnt1..Cnt5 типа INT, в которых будут храниться значения каждого из пяти
счетчиков. Далее необходимо обратиться к редактору языка FBD. Для
написания алгоритма и логики выполнения данной программы нам понадобятся
функциональные блоки счетчиков, создание которых рассмотрено в п. 6.3.2.

Для удобства редактирования FBD диаграмм в редакторе существует функция
Drag\&Drop , необходимые функциональные блоки и
переменные можно добавить в поле редактирования из библиотеки функций и
функциональных блоков и таблицы переменных путем
перетаскивания в поле редактирования. необходимо левой
клавишей мыши зажать столбец «\#» для переменной в панели переменных и
констант, далее перенести указатель на область редактирования FBD
диаграммы и отпустить кнопку мыши (Drag\&Drop).

Перенесем 5 экземпляров переменной Reset и все переменные Cnt1..Cnt5 в
поле редактирования диаграммы как показано на \hyperref[usage_guide/work_with_project:image155]{Рисунок \ref{usage_guide/work_with_project:image155} }:
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.08574in,height=4.35274in]{{image155}.png}
\caption{- Перенос переменных в поле редактирования}\label{usage_guide/work_with_project:image155}\end{figure}

Из библиотеки функций и функциональных блоков добавим пользовательские
функциональные блоки. Добавление данных функциональных блоков удобнее
осуществить переносом соответствующей функции с помощью мыши (Drag\&Drop)
из панели библиотеки функций и функциональных блоков в область
редактирования FBD диаграммы данного программного модуля как показано
на \hyperref[usage_guide/work_with_project:image156]{Рисунок \ref{usage_guide/work_with_project:image156} }:
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.61565in,height=4.56977in]{{image156}.png}
\caption{- Программа на языке FBD без связей}\label{usage_guide/work_with_project:image156}\end{figure}

Добавим связи между функциональными блоками и входными и выходными
переменными.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.93338in,height=5in]{{image157}.png}
\caption{- Основной программный модуль на языке FBD}\label{usage_guide/work_with_project:image157}\end{figure}


\paragraph{Функциональный блок}
\label{usage_guide/work_with_project:id9}
Добавление пользовательского функционального блока происходит путем
нажатия на пункт «Функциональный блок» во всплывающем меню дерева
проекта . В диалоговом окне (см. \hyperref[usage_guide/work_with_project:image158]{Рисунок \ref{usage_guide/work_with_project:image158} }) задайте имя
функционального блока в поле «Имя POU», в поле «Тип POU» выберите
«функциональный блок», в поле «Язык» выберите язык, на котором будет
написан алгоритм работы блока.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.67442in,height=2.96774in]{{image158}.png}
\caption{- Диалог создания нового функционального блока}\label{usage_guide/work_with_project:image158}\end{figure}

\textbf{Функциональный блок на языке ST}

Создайте функциональный блок с именем «CounterST» (см. \hyperref[usage_guide/work_with_project:image159]{Рисунок \ref{usage_guide/work_with_project:image159} }), в
котором инструментами языка ST будет реализован счетчик , принимающий на
вход переменную Reset типа BOOL, и возвращающий значение счетчика Out.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.875in,height=2.18167in]{{image159}.png}
\caption{- Диалог добавления пользовательского функционального блока}\label{usage_guide/work_with_project:image159}\end{figure}

В отличие от функции, функциональный блок может быть описан на любом
языке стандарта IEC 61131-3, включая язык SFC. На \hyperref[usage_guide/work_with_project:image160]{Рисунок \ref{usage_guide/work_with_project:image160} } показана
реализация данного функционального блока на языке ST.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=7.27511in,height=3.08333in]{{image160}.png}
\caption{- описание пользовательского функционального блока на языке ST}\label{usage_guide/work_with_project:image160}\end{figure}

Возвращаемое значение «Out» имеет тип INT и класс «Выход». Добавленные
локальная переменная «Cnt» и внешняя конфигурационная переменная
«ResetCounterValue» имеют тип INT, входная переменная «Reset» имеет тип
BOOL. Реализованный функциональный блок становится доступным в панели
библиотеки функций и функциональных блоков и может
использоваться в программных модулях типа «Программа» и «Функциональный
блок». На \hyperref[usage_guide/work_with_project:image161]{Рисунок \ref{usage_guide/work_with_project:image161} } показано использование созданного функционального
блока «CounterST» в основном программном модуле, написанном на языке
FBD.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.70833in,height=2.94044in]{{image161}.png}
\caption{- Использование созданного функционального блока CounterST в основном программном модуле}\label{usage_guide/work_with_project:image161}\end{figure}

С входом «Reset» соединена общая для всех счетчиков переменная «Reset»
типа BOOL, результат выполнения помещается в переменную «Cnt1» типа INT.
Следует отметить, что при попытке удаления функции или функционального
блока из проекта (см. \hyperref[usage_guide/work_with_project:image162]{Рисунок \ref{usage_guide/work_with_project:image162} }), где эти добавленные программные модули
уже используются, будет выдана ошибка.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.75in,height=1.4537in]{{image162}.png}
\caption{- Сообщение об ошибке при удалении функционального блока}\label{usage_guide/work_with_project:image162}\end{figure}

Реализации на других языках полностью идентичны по набору входных,
выходных и локальных переменных. Далее будут описаны примеры
функциональных блоков на остальных четырех языках IEC 61131-3.

\textbf{Функциональный блок на языке FBD}

Создайте функциональный блок с именем «CounterFBD», в котором
инструментами языка FBD будет реализован счетчик , принимающий на вход
переменную «Reset» типа BOOL, и возвращающий значение счетчика «Out».
Для удобства редактирования FBD диаграмм в редакторе существует функция
Drag\&Drop , необходимые функциональные блоки и
переменные можно добавить в поле редактирования из библиотеки функций и
функциональных блоков и таблицы переменных путем
перетаскивания в поле редактирования (см. \hyperref[usage_guide/work_with_project:image163]{Рисунок \ref{usage_guide/work_with_project:image163} }). необходимо левой
клавишей мыши зажать столбец «\#» для переменной в панели переменных и
констант, далее перенести указатель на область редактирования FBD
диаграммы и отпустить кнопку мыши (Drag\&Drop).

Добавим возвращаемое значение «Out» типа INT и класса «Выход», локальную
переменную «Cnt» типа INT, внешнюю конфигурационную переменную
«ResetCounterValue» типа INT, и входную переменную «Reset» типа BOOL.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.97708in,height=2.63542in]{{image163}.png}
\caption{- Добавление переменной в поле редактирования}\label{usage_guide/work_with_project:image163}\end{figure}

Перенесенные на поле редактирования переменные отображаются как
прямоугольные блоки с коннекторами входа и выхода(см. \hyperref[usage_guide/work_with_project:image164]{Рисунок \ref{usage_guide/work_with_project:image164} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.29167in,height=1.72917in]{{image164}.png}
\caption{- Блоки переменных в поле редактирования}\label{usage_guide/work_with_project:image164}\end{figure}

После переноса в поле редактирования всех переменных, добавьте числовой
литерал со значением «1» при помощи кнопки «Создать новую
переменную», в диалоговом окне создания переменной в поле «Выражение»
напишите «1» (см. \hyperref[usage_guide/work_with_project:image165-2]{Рисунок \ref{usage_guide/work_with_project:image165-2} }). Таким способом задается шаг инкрементации
счетчика.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.98958in,height=3.05219in]{{image165}.png}
\caption{- Диалог создания переменной}\label{usage_guide/work_with_project:image165-2}\end{figure}

Для того чтобы переменной «Cnt» можно было одновременно и присвоить
значение и передать это значение переменной Out, задайте класс
переменной «Вход/Выход». Сделать это можно щелчком правой кнопкой мыши
по блоку переменной, во всплывающем меню следует выбрать «Вход/Выход»
(см. \hyperref[usage_guide/work_with_project:image166]{Рисунок \ref{usage_guide/work_with_project:image166} }), или щелкнув по блоку двойным щелчком левой кнопки мыши,
выбрав в выпадающем списке «Класс» вариант «Вход/Выход»(см. \hyperref[usage_guide/work_with_project:image167]{Рисунок \ref{usage_guide/work_with_project:image167} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.46875in,height=1.64583in]{{image166}.png}
\caption{- Выбор коннектора для блока переменной}\label{usage_guide/work_with_project:image166}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.97917in,height=3.06496in]{{image167}.png}
\caption{- Диалог редактирования свойств блока переменной}\label{usage_guide/work_with_project:image167}\end{figure}

Далее необходимо обратиться к редактору языка FBD. Для написания
алгоритма и логики выполнения данной программы будут добавлены две
функции: «ADD» и «SEL».

Функция «ADD» находится во вкладке «Математика» в Библиотеке функций и
функциональных блоков , обозначает сложение от 2 до 20
входных значений (в нашем примере их 2) на входах «IN1» и «IN2»,
возвращает результат вычисления на выход «OUT».

Функция «SEL» обозначает «Выбор одного из двух значений» и находится во
вкладке «Операции выбора». Она содержит три входных переменных «G»,
«IN0», «IN1» и одну выходную «OUT». Если «G» равно 0 (или FALSE), то
выходной переменной «OUT» присваивается значение «IN0». Если «G» равно 1
(или TRUE), то выходной переменной «OUT» присваивается значение «IN1».

Добавление данных функций удобнее осуществить переносом соответствующей
функции с помощью мыши (Drag\&Drop) из панели Библиотеки функций и
функциональных блоков в область редактирования FBD диаграммы
функционального блока. Результатом вышеизложенных действий должна стать
FBD диаграмма без соединений (см. \hyperref[usage_guide/work_with_project:image168]{Рисунок \ref{usage_guide/work_with_project:image168} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.67708in,height=1.97877in]{{image168}.png}
\caption{- FBD диаграмма без соединений}\label{usage_guide/work_with_project:image168}\end{figure}

Следующим шагом станет соединение выходов переменных со входами функций.
Соединим числовой литерал 1 с входом «IN1» функции ADD, а выход «OUT»
функции ADD соединим с входом «IN0» функции SEL. В свою очередь, выход
«OUT» функции SEL соединим с входным коннектором переменной Cnt, а
выходной коннектор переменной Cnt соединим с входом переменной «Out».
Соединение блоков осуществляется путем зажатия левой кнопки мыши на
коннекторе блока, будет создана линия связи которую необходимо протянуть
до коннектора присоединяемого блока (см. \hyperref[usage_guide/work_with_project:image169]{Рисунок \ref{usage_guide/work_with_project:image169} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.33333in,height=2.03435in]{{image169}.png}
\caption{- Соединение блоков в FBD диаграмме}\label{usage_guide/work_with_project:image169}\end{figure}

Далее присоединим переменную «Reset», управляющую сбросом счетчика, на
вход «G» функции «SEL», а конфигурационную переменную
«ResetCounterValue» на вход «IN1». Таким образом, меняя значение
переменной «Reset» мы управляем значением переменной «Cnt» через функцию
выбора значения «SEL» . Осталось добавить связь между переменной «Cnt» и
входом «IN2» функции сложения ADD, тем самым обеспечив увеличение
значения счетчика на 1 за один цикл ПЛК.

Полученная реализация алгоритма счетчика на языке FBD представлена
на \hyperref[usage_guide/work_with_project:image170]{Рисунок \ref{usage_guide/work_with_project:image170} }.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.95531in,height=3.46875in]{{image170}.png}
\caption{- Функциональный блок на языке FBD}\label{usage_guide/work_with_project:image170}\end{figure}

Функциональный блок становится доступным в панели библиотеки функций и
функциональных блоков и может использоваться в программных
модулях типа «Программа» и «Функциональный блок». На \hyperref[usage_guide/work_with_project:image171]{Рисунок \ref{usage_guide/work_with_project:image171} } показано
использование созданного функционального блока «CounterFBD» в основном
программном модуле, написанном на языке FBD.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=7.02326in,height=3.22318in]{{image171}.png}
\caption{- Использование созданного функционального блока CounterFBD в основном программном модуле}\label{usage_guide/work_with_project:image171}\end{figure}

\textbf{Функциональный блок на языке SFC}

Создайте функциональный блок с именем «CounterSFC», в котором
инструментами языка SFC будет реализован счетчик , принимающий на вход
переменную «Reset» типа BOOL, и возвращающий значение счетчика «Out».

Добавим в панель переменных и констант возвращаемое значение «Out» типа
INT и класса «Выход», локальную переменную «Cnt» типа INT, внешнюю
конфигурационную переменную «ResetCounterValue» типа INT, и входную
переменную «Reset» типа BOOL.

Для удобства редактирования SFC диаграмм в редакторе существует функция
Drag\&Drop, необходимые функциональные блоки и
переменные можно добавить в поле редактирования из библиотеки функций и
функциональных блоков и таблицы переменных путем
перетаскивания в поле редактирования (см. \hyperref[usage_guide/work_with_project:image163]{Рисунок \ref{usage_guide/work_with_project:image163} }). необходимо левой
клавишей мыши зажать столбец «\#» для переменной в панели переменных и
констант, далее перенести указатель на область редактирования SFC
диаграммы и отпустить кнопку мыши (Drag\&Drop).

Добавим начальный шаг диаграммы, нажав на кнопку «Создать исходный шаг»,
в диалоге изменим название шага по умолчанию на название «Start»,
коннектор потребуется только «Выход»(cм. \hyperref[usage_guide/work_with_project:image172]{Рисунок \ref{usage_guide/work_with_project:image172} })
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.97917in,height=2.25271in]{{image172}.png}
\caption{- Добавление начального шага}\label{usage_guide/work_with_project:image172}\end{figure}

Следуя алгоритму, возможны два состояния – счетчик увеличивается и
счетчик сброшен. Добавим альтернативное ветвление с двумя ветвями.
Согласно стандарту IEC 61131-3, каждая ветвь
альтернативного ветвления должна оканчиваться переходом. Условиями
переходов будет являться состояние переменной «Reset» : для первой ветви
выражение «NOT Reset» , для второй ветви просто значения «Reset» (см.:numref:\sphinxtitleref{image173}).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.38807in,height=2.94584in]{{image173}.png}
\caption{- Добавление альтернативного ветвления}\label{usage_guide/work_with_project:image173}\end{figure}

В первом состоянии добавим шаг с действием «Count» (см. \hyperref[usage_guide/work_with_project:image174]{Рисунок \ref{usage_guide/work_with_project:image174} }), в
действии на языке ST опишем увеличение счетчика на единицу, и присвоение
значения переменной «Out» (см. \hyperref[usage_guide/work_with_project:image175]{Рисунок \ref{usage_guide/work_with_project:image175} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.12791in,height=2.41452in]{{image174}.png}
\caption{- Добавление шага с коннектором действия}\label{usage_guide/work_with_project:image174}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.24419in,height=3.08618in]{{image175}.png}
\caption{- Добавление действия инкрементации счетчика}\label{usage_guide/work_with_project:image175}\end{figure}

Во второй ветви добавим шаг с действием «ResetCounter», в действии
опишем присвоение переменной «Cnt» значение переменной
«ResetCounterValue», и значению «Out» значение переменной «Cnt» (см.:numref:\sphinxtitleref{image176}).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.30547in,height=3.0864in]{{image176}.png}
\caption{- Добавление действия сброса счетчика}\label{usage_guide/work_with_project:image176}\end{figure}

Первая ветвь отвечает за инкрементацию счетчика, вторая – за сброс (см. \hyperref[usage_guide/work_with_project:image177]{Рисунок \ref{usage_guide/work_with_project:image177} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.11313in,height=2.12972in]{{image177}.png}
\caption{- Шаги с действиями}\label{usage_guide/work_with_project:image177}\end{figure}

Для выходов из состояния добавим в первой ветви переход с условием
«Reset», во второй ветви добавим переход с условием «NOT Reset»(см. \hyperref[usage_guide/work_with_project:image178]{Рисунок \ref{usage_guide/work_with_project:image178} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.31358in,height=2.13954in]{{image178}.png}
\caption{- Условные переходы для выхода из состояний}\label{usage_guide/work_with_project:image178}\end{figure}

Далее, объединим ветви альтернативным объединением. Для того чтобы
программа выполнялась циклически, после объединения добавим безусловный
переход к начальному шагу «Start». Полученная реализация счетчика на
языке SFC представлена на \hyperref[usage_guide/work_with_project:image179]{Рисунок \ref{usage_guide/work_with_project:image179} }.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.47331in,height=4.20609in]{{image179}.png}
\caption{- Реализация счетчика на языке SFC}\label{usage_guide/work_with_project:image179}\end{figure}

Функциональный блок становится доступным в панели библиотеки функций и
функциональных блоков и может использоваться в программных
модулях типа «Программа» и «Функциональный блок». На
\hyperref[usage_guide/work_with_project:image180]{Рисунок \ref{usage_guide/work_with_project:image180} } показано
использование созданного функционального блока «CounterSFC» в основном
программном модуле, написанном на языке FBD.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.92947in,height=3.67442in]{{image180}.png}
\caption{- Использование созданного функционального блока CounterSFC в основном программном модуле}\label{usage_guide/work_with_project:image180}\end{figure}

\textbf{Функциональный блок на языке IL}

Создайте функциональный блок с именем «CounterIL», в котором
инструментами языка IL будет реализован счетчик , принимающий на вход
переменную Reset типа BOOL, и возвращающий значение счетчика Out.

Добавим в панель переменных и констант возвращаемое значение «Out» типа
INT и класса «Выход», локальную переменную «Cnt» типа INT, внешнюю
конфигурационную переменную «ResetCounterValue» типа INT, и входную
переменную «Reset» типа BOOL.

Для удобства редактирования кода в редакторе IL существует функция
Drag\&Drop , необходимые переменные можно добавить в поле
редактирования из таблицы переменных путем перетаскивания в поле
редактирования (см. \hyperref[usage_guide/work_with_project:image162]{Рисунок \ref{usage_guide/work_with_project:image162} }). необходимо левой клавишей мыши зажать
столбец «\#» для переменной в панели переменных и констант, далее
перенести указатель на область редактирования и отпустить кнопку мыши
(Drag\&Drop).

Напишем инструкции для сброса счетчика и сохранения результатов.
Инструкцию для сброса счетчика назовем «ResetCnt», она загрузит операнд
ResetCounterValue в аккумулятор:

\begin{Verbatim}[commandchars=\\\{\}]
ResetCnt:
(\PYGZbs{}* reset counter \PYGZbs{}*)
LD ResetCounterValue
\end{Verbatim}

Инструкцию для сохранения результатов назовем «QuitFb», она будет
сохранять значения операндов «Cnt» и «Out»:

\begin{Verbatim}[commandchars=\\\{\}]
QuitFb:
(\PYGZbs{}* save results \PYGZbs{}*)
ST Cnt
ST Out
\end{Verbatim}

Загрузим в аккумулятор значение операнда «Reset». Если значение операнда
«True», следует перейти к инструкции сброса счетчика ResetCnt, в случае
значения «False» значение операнда должно увеличиться на единицу.

\begin{Verbatim}[commandchars=\\\{\}]
LD Reset
JMPC ResetCnt
(\PYGZbs{}* increment counter \PYGZbs{}*)
LD Cnt
ADD 1
JMP QuitFb
ResetCnt:
(\PYGZbs{}* reset counter \PYGZbs{}*)
LD ResetCounterValue
QuitFb:
(\PYGZbs{}* save results \PYGZbs{}*)
ST Cnt
ST Out
\end{Verbatim}

Полученная реализация счетчика на языке IL представлена на \hyperref[usage_guide/work_with_project:image181]{Рисунок \ref{usage_guide/work_with_project:image181} }.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.64388in,height=4.2142in]{{image181}.png}
\caption{- Реализация счетчика на языке IL}\label{usage_guide/work_with_project:image181}\end{figure}

Функциональный блок становится доступным в панели библиотеки функций и
функциональных блоков  и может использоваться в программных
модулях типа «Программа» и «Функциональный блок». На \hyperref[usage_guide/work_with_project:image182]{Рисунок \ref{usage_guide/work_with_project:image182} } показано
использование созданного функционального блока «CounterIL» в основном
программном модуле, написанном на языке FBD.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.44621in,height=4.75469in]{{image182}.png}
\caption{- Использование функционального блока CounterIL в основном программном модуле}\label{usage_guide/work_with_project:image182}\end{figure}

\textbf{Функциональный блок на языке LD}

Создайте функциональный блок с именем «CounterLD», в котором
инструментами языка LD будет реализован счетчик , принимающий на вход
переменную «Reset» типа BOOL, и возвращающий значение счетчика «Out».

Добавим в панель переменных и констант возвращаемое значение «Out» типа
INT и класса «Выход», локальную переменную «Cnt» типа INT, внешнюю
конфигурационную переменную «ResetCounterValue» типа INT, и входную
переменную «Reset» типа BOOL.

Для удобства редактирования LD диаграмм в редакторе существует функция
Drag\&Drop , необходимые функциональные блоки и
переменные можно добавить в поле редактирования из библиотеки функций и
функциональных блоков  и таблицы переменных путем
перетаскивания в поле редактирования (см. \hyperref[usage_guide/work_with_project:image163]{Рисунок \ref{usage_guide/work_with_project:image163} }). необходимо левой
клавишей мыши зажать столбец «\#» для переменной в панели переменных и
констант, далее перенести указатель на область редактирования LD
диаграммы и отпустить кнопку мыши (Drag\&Drop).

Добавим шину питания, к ней присоединим контакт, связанный с переменной
«Reset» (см. \hyperref[usage_guide/work_with_project:image183]{Рисунок \ref{usage_guide/work_with_project:image183} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.34884in,height=2.83296in]{{image183}.png}
\caption{- Диалог добавления контакта}\label{usage_guide/work_with_project:image183}\end{figure}

Полученная конструкция будет подавать сигнал на сброс счетчика при
переходе значения переменной «Reset» в True (см. \hyperref[usage_guide/work_with_project:image184]{Рисунок \ref{usage_guide/work_with_project:image184} })
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.38542in,height=0.77083in]{{image184}.png}
\caption{- Контакт ассоциированный с переменной Reset}\label{usage_guide/work_with_project:image184}\end{figure}

Далее добавим числовой литерал со значением «1» при
помощи кнопки «Создать новую переменную», в диалоговом окне создания
переменной в поле «Выражение» напишите «1» (см. \hyperref[usage_guide/work_with_project:image165]{Рисунок \ref{usage_guide/work_with_project:image165} }). Таким способом
задается шаг инкрементации счетчика.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.98958in,height=3.05219in]{{image165}.png}
\caption{- Диалог создания переменной}\label{usage_guide/work_with_project:image165}\end{figure}

Перенесенные на поле редактирования переменные отображаются как
прямоугольные блоки с коннекторами входа и выхода(см. \hyperref[usage_guide/work_with_project:image185]{Рисунок \ref{usage_guide/work_with_project:image185} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.55208in,height=1.95833in]{{image185}.png}
\caption{- Блоки переменных в поле редактирования}\label{usage_guide/work_with_project:image185}\end{figure}

Для того чтобы переменной «Cnt» можно было одновременно и присвоить
значение и передать это значение переменной Out, задайте класс
переменной «Вход/Выход». Сделать это можно щелчком правой кнопкой мыши
по блоку переменной, во всплывающем меню следует выбрать «Вход/Выход»
(см. \hyperref[usage_guide/work_with_project:image166-2]{Рисунок \ref{usage_guide/work_with_project:image166-2} }), или щелкнув по блоку двойным щелчком левой кнопки мыши,
выбрав в выпадающем списке «Класс» вариант «Вход/Выход»(см. \hyperref[usage_guide/work_with_project:image167-2]{Рисунок \ref{usage_guide/work_with_project:image167-2} }).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.46875in,height=1.64583in]{{image166}.png}
\caption{- Выбор коннектора для блока переменной}\label{usage_guide/work_with_project:image166-2}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.97917in,height=3.06496in]{{image167}.png}
\caption{- Диалог редактирования свойств блока переменной}\label{usage_guide/work_with_project:image167-2}\end{figure}

Для написания алгоритма и логики выполнения данной программы будут
добавлены две функции: «ADD» и «SEL».

Функция «ADD» находится во вкладке «Математика» в Библиотеке функций и
функциональных блоков, и обозначает сложение от 2 до 20
входных значений (в нашем примере их 2) на входах «IN1» и «IN2»,
возвращает результат вычисления на выход «OUT».

Функция «SEL» обозначает «Выбор одного из двух значений» и находится во
вкладке «Операции выбора». Она содержит три входных переменных «G»,
«IN0», «IN1» и одну выходную «OUT». Если «G» равно 0 (или FALSE), то
выходной переменной «OUT» присваивается значение «IN0». Если «G» равно 1
(или TRUE), то выходной переменной «OUT» присваивается значение «IN1».

Добавление данных функций удобнее осуществить переносом соответствующей
функции с помощью мыши (Drag\&Drop) из панели Библиотеки функций и
функциональных блоков в область редактирования FBD диаграммы
функционального блока. Результатом вышеизложенных действий должна стать
LD диаграмма без соединений.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.95664in,height=2.3903in]{{image186}.png}
\caption{- LD диаграмма без соединений}\label{usage_guide/work_with_project:image186}\end{figure}

Следующим шагом станет соединение выходов переменных со входами функций.
Соединим числовой литерал 1 с входом «IN1» функции ADD, а выход «OUT»
функции ADD соединим с входом «IN0» функции SEL. В свою очередь, выход
«OUT» функции SEL соединим с входным коннектором переменной Cnt, а
выходной коннектор переменной Cnt соединим с входом переменной «Out».
Соединение блоков осуществляется путем зажатия левой кнопки мыши на
коннекторе блока, будет создана линия связи которую необходимо протянуть
до коннектора присоединяемого блока .
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.08261in,height=2.47501in]{{image187}.png}
\caption{- Соединение блоков}\label{usage_guide/work_with_project:image187}\end{figure}

Далее присоединим сигнал с контакта, ассоциированного с переменной
«Reset», управляющей сбросом счетчика, на вход «G» функции «SEL», а
конфигурационную переменную «ResetCounterValue» на вход «IN1». Таким
образом, меняя значение переменной «Reset» мы управляем значением
переменной «Cnt» через функцию выбора значения «SEL» . Осталось добавить
связь между переменной «Cnt» и входом «IN2» функции сложения ADD, тем
самым обеспечив увеличение значения счетчика на 1 за один цикл ПЛК.

Полученная реализация алгоритма счетчика на языке LD представлена
на \hyperref[usage_guide/work_with_project:image188]{Рисунок \ref{usage_guide/work_with_project:image188} }.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.91132in,height=4.22355in]{{image188}.png}
\caption{- Функциональный блок на языке LD}\label{usage_guide/work_with_project:image188}\end{figure}

Функциональный блок становится доступным в панели библиотеки функций и
функциональных блоков и может использоваться в программных
модулях типа «Программа» и «Функциональный блок». На рис. 146 показано
использование созданного функционального блока «CounterFBD» в основном
программном модуле, написанном на языке FBD.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=7.03923in,height=4.89552in]{{image189}.png}
\caption{- Использование функционального блока на языке LD в основном программном модуле}\label{usage_guide/work_with_project:image189}\end{figure}

Функция

Добавление пользовательской функционального блока происходит путем
нажатия на пункт «Функция» во всплывающем меню дерева проекта.
В диалоговом окне задайте имя функции в поле
«Имя POU», в поле «Тип POU» выберите «функция», в поле «Язык» выберите
язык, на котором будет написан алгоритм работы функции.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.11275in,height=2.37209in]{{image190}.png}
\caption{- Диалог создания функции}\label{usage_guide/work_with_project:image190}\end{figure}

Создадим функцию «AverageVal» на языке ST, которая будет вычислять
среднее значение счетчиков в цикле. Поскольку счетчики никак не
синхронизированы, среднее значение должно быть дробным. Выберем тип
возвращаемого значения функции – для дробного значения это тип REAL.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.92288in,height=3.7907in]{{image191}.png}
\caption{- Выбор типа возвращаемого значения функции}\label{usage_guide/work_with_project:image191}\end{figure}

В панели редактирования переменных и констант добавим пять переменных
«Cnt1»..«Cnt5» типа INT, класса «Вход». К этим входам будут подключены
выходные значения функциональных блоков, рассмотреных выше.
Добавим переменную «InputsNumber» типа REAL, класса «Локальный».

Далее в редакторе языка ST пишется алгоритм и логика работы данной
функции, как показано на рис. 149:
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.63225in,height=2.98798in]{{image192}.png}
\caption{- Определение алгоритма и логики выполнения функции}\label{usage_guide/work_with_project:image192}\end{figure}

Для приведения типа INT к типу REAL воспользуемся функцией INT\_TO\_REAL
из библиотеки функций и функциональных блоков, она преобразует значение
типа INT на входе IN в значение типа REAL на выходе OUT (INT:IN)
=\textgreater{}(REAL:OUT).

Добавим функцию в основной программный модуль. На панели библиотеки
функций и функциональных блоков в разделе «Пользовательские POU»
необходимо выбрать функцию «AverageVal» и с помощью указателя мыши
(зажав левую кнопку мыши) перенести данную функцию (Drag\&Drop) в область
редактирования FBD диаграммы программного модуля «program0».
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.83721in,height=2.12601in]{{image193}.png}
\caption{- Добавление на FBD диаграмму пользовательской функции}\label{usage_guide/work_with_project:image193}\end{figure}

Подключим к входам функции значения пяти счетчиков. Для сохранения
результата вычисления функции создадим переменную «AVCnt». На \hyperref[usage_guide/work_with_project:image194]{Рисунок \ref{usage_guide/work_with_project:image194} }
показано использование созданной функции «AverageVal» в основном
программном модуле, написанном на языке FBD.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.30667in,height=4.30564in]{{image194}.png}
\caption{- Использование функции в основном программном модуле}\label{usage_guide/work_with_project:image194}\end{figure}


\subsubsection{Ресурс}
\label{usage_guide/work_with_project:id10}
Согласно стандарту IEC 61131-3, каждый проект должен иметь как минимум
один ресурс, с определённым в нём как минимум одним экземпляром.
Экземпляр представляет собой элемент, связанный с программным модулем
типа «Программа» и одной определённой задачей. По умолчанию,
инструментальная среда разработки Beremiz создаёт для нового проекта
один ресурс.


\paragraph{Глобальные переменные ресурса}
\label{usage_guide/work_with_project:id11}
Глобальные переменные ресурса объявляются аналогично глобальным
переменным проекта на панели переменных и констан
выбранного ресурса с использованием кнопки «Добавить
переменную», либо «Добавить переменные» (см. таблицу 3).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=7.06977in,height=1.54159in]{{image195}.png}
\caption{- Пример объявления в проекте глобальной переменной}\label{usage_guide/work_with_project:image195}\end{figure}

Использование данных глобальных переменных на уровне ресурса также
аналогично использованию конфигурационных переменных проекта в
программных модулях. Для использования в программном модуле глобальной
переменной ресурса, добавьте в модуль переменную класса «Внешняя» с
таким же именем, как у глобальной переменной, объявленные выше для
ресурса.


\paragraph{Задачи и экземпляры ресурса}
\label{usage_guide/work_with_project:id12}
Для создания экземпляра необходимо наличие как минимум одного
программного модуля типа «Программа» в проекте и как минимум одной
задачи, определённой в панели редактирования ресурса.

После добавления задачи с помощью кнопки «Добавить» (данная кнопка
аналогична кнопки «Добавить» на панели переменных и констант),
необходимо задать её уникальное имя (поле «Имя») и выбрать тип
выполнения задачи (поле «Запуск», см. \hyperref[usage_guide/work_with_project:image196]{Рисунок \ref{usage_guide/work_with_project:image196} }):
\begin{itemize}
\item {} 
«Циклический» – выполнение программного модуля типа «Программа» через
заданный интервал времени, указанный в поле «Интервал»;

\item {} 
«Прерывание» – выполнение программного модуля типа «Программа» один
раз при наступлении значения TRUE глобальной переменной типа BOOL,
определённой на уровне проекта, либо на уровне ресурса, указанной в
поле «Источник».

\end{itemize}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.301in,height=1.68605in]{{image196}.png}
\caption{- Выбор типа выполнения задачи}\label{usage_guide/work_with_project:image196}\end{figure}

В случае выбора типа выполнения «Цикличное», в поле «Интервал»
необходимо указать интервал, с которым будет выполняться данная задача.
Двойной щелчок левой кнопкой мыши по полю «Интервал» приводит к
появлению кнопки «...».
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.25436in,height=0.97545in]{{image197}.png}
\caption{- Добавление задачи с цикличным режимом выполнения}\label{usage_guide/work_with_project:image197}\end{figure}

Нажатие данной кнопки вызывает диалог «Редактировать продолжительность»
в котором можно указать время, используя микросекунды,
миллисекунды, секунды, минуты, часы и дни.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.23382in,height=1.58348in]{{image198}.png}
\caption{- Диалог редактирования длительности задачи}\label{usage_guide/work_with_project:image198}\end{figure}

Завершение ввода времени кнопкой «OK» приводит к закрытию диалога и
добавлению данного интервала времени в поле «Интервал» добавляемой
задачи.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.84375in,height=1in]{{image199}.png}
\caption{- Добавленный итервал выполнения}\label{usage_guide/work_with_project:image199}\end{figure}

В случае выбора типа выполнения «Прерывание» в поле «Источник»
необходимо указать переменную типа BOOL, определённую глобально либо на
уровне проекта, либо на уровне ресурса.
На \hyperref[usage_guide/work_with_project:image200]{Рисунок \ref{usage_guide/work_with_project:image200} } выбирается переменная «globalFlag», определённая в данном
ресурсе.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.84375in,height=1.79167in]{{image200}.png}
\caption{- Выбор переменной типа BOOL как источника прерывания для начала выполнения задачи}\label{usage_guide/work_with_project:image200}\end{figure}

Задача будет выполнена один раз, как только значение переменной,
определённой в этом поле, будет TRUE. Поле «Приоритет» позволяет указать
приоритет выполнения задачи, по умолчанию все задачи имеют приоритет 0.
Следует отметить, что в ресурсе должна быть определена как минимум одна
задача с типом выполнения «Цикличное», в противном случае будет ошибка в
компиляции в отладочной консоли . После того как задачи
определены, их можно использовать в экземплярах. Создание экземпляра
происходит аналогичным образом с помощью кнопки «Добавить». Необходимо
выбрать уникальное имя экземпляра и далее указать программный модуль
типа «Программа» в поле «Тип» и одну из задач в поле «Задача». Например,
в проекте определено два программных модуля типа «Программа»: «program0»
и «program1».
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.04167in,height=1.64583in]{{image201}.png}
\caption{- Проект, содержащий два программных модуля типа ``Программа''}\label{usage_guide/work_with_project:image201}\end{figure}

Соответственно, при создании экземпляра в поле «Тип» оба этих
программных модуля будут доступны (см. рис. 159).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.97382in,height=3.9311in]{{image202}.png}
\caption{- Выбор программного модуля типа ``Программа'' для экземпляра}\label{usage_guide/work_with_project:image202}\end{figure}

Аналогичным образом выбирается задача из списка, в котором будут
отображены определённые ранее задачи.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.95507in,height=3.87351in]{{image203}.png}
\caption{- Выбор задачи для экземпляра}\label{usage_guide/work_with_project:image203}\end{figure}

В каждом проекте в ресурсе должен быть определен как минимум один
экземпляр, в противном случае будет ошибка выдана компиляции в
отладочной консоли.


\subsubsection{Типы данных}
\label{usage_guide/work_with_project:id13}
Добавление типа данных происходит выбором пункта «Типа данных» в меню
дерева проекта (см. \hyperref[usage_guide/work_with_project:image204]{Рисунок \ref{usage_guide/work_with_project:image204} }) в уже созданный проект, содержащий
программный модуль типа «Программа» – «program0».
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.5in,height=4.73958in]{{image204}.png}
\caption{- Выбор пункта меню добавления пользовательского типа данных в дереве проекта}\label{usage_guide/work_with_project:image204}\end{figure}

Будет создан массив типа INT размерностью 11 элементов. В дереве проекта
появится панель редактирования добавленного типа данных с именем
«datatype0». В поле «Механизм создания нового типа»
необходимо выбрать «Массив» и указать тип INT, как показано на \hyperref[usage_guide/work_with_project:image205]{Рисунок \ref{usage_guide/work_with_project:image205} }:
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=7.16713in,height=3.76468in]{{image205}.png}
\caption{- Выбор базового типа для массива}\label{usage_guide/work_with_project:image205}\end{figure}

С помощью кнопки «Добавить» (см. таблицу 10) создаётся поле для массива
с указанием его размерности в соответствующем формате.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.99974in,height=2.77907in]{{image206}.png}
\caption{- Задание размерности для массива}\label{usage_guide/work_with_project:image206}\end{figure}

После выполнения вышеперечисленных операций тип «datatype0» может быть
использован для определения переменных в программных модулях, так же как
и базовые типы данных.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.70202in,height=2.01872in]{{image207}.png}
\caption{- Выбор добавленного типа данных в панели переменных и констант программного модуля}\label{usage_guide/work_with_project:image207}\end{figure}


\subsubsection{Сборка и передача на целевое устройство прикладной программы}
\label{usage_guide/work_with_project:id14}
Следующими шагами после создания основных элементов проекта является его
сборка (компиляция и компоновка), передача полученного исполняемого
файла на целевое устройство и отладка данной прикладной программы.

Сборка проекта осуществляется с помощью соответствующих кнопок,
находящихся на панели инструментов . Для успешного
завершения данной операции каждый проект должен иметь как минимум один
ресурс (как уже упоминалось, при создании проекта по умолчанию ресурс
будет создан). В ресурсе должна быть определена, как минимум, одна
задача циклического типа и, как минимум, один экземпляр. Соответственно,
проект обязан содержать, как минимум, один программный модуль типа
«Программа», причём тело, т.е. алгоритм и логика его выполнения, не
может быть пустым (в противном случае будет ошибка компиляции).

Возможность передачи на целевое устройство прикладной программы и её
отладки определяется наличием запущенной на целевом устройстве серверной
части среды разработки Beremiz.

Среда разработки Beremiz предоставляет следующие возможности отладки:
\begin{itemize}
\item {} 
Просмотр и изменение значения всех переменных проекта, используя
панель отладки;

\item {} 
Визуально отслеживание выполнения программ на графических языках и
изменение значения различных графических элементов конкретного языка;

\item {} 
Отображение значений переменных в виде графика.

\end{itemize}

Далее подробнее рассказывается про сборку прикладной программы,
соединение с целевым устройством и передачу на него исполняемого файла и
его отладке.


\paragraph{Сборка прикладной программы}
\label{usage_guide/work_with_project:id15}
Прежде чем проект будет передан ПЛК, его необходимо собрать. Настроить
целевую платформу для сборки можно в окне настройки проекта,
на вкладке Конфигурация.

Для сборки проекта нажмите кнопку «Сборка проекта в директории сборки»
(см. табл. 2). Результаты сборки
выводятся в консоль, расположенную в нижней части окна программы, ошибки
сборки выделяются красным цветом. На примере проекта First\_steps после
сборки в консоль выведено сообщение о том, что сборка проведена успешно.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=7.1039in,height=2.3393in]{{image209}.png}
\caption{- Результаты сборки выведены в консоль}\label{usage_guide/work_with_project:image209}\end{figure}

Пересборку проекта можно осуществить, очистив директорию сборки проекта
нажатием на кнопку «Очистить директорию сборки проекта» (см. табл.2).
Будет удален сгенерированный на языке ST код проекта и скомпилированный
бинарный файл прошивки ПЛК. После этого нажмите кнопку «Сборка проекта в
директории сборки», и проект будет собран заново.


\paragraph{Запуск серверной части для отладки}
\label{usage_guide/work_with_project:id16}
Серверная часть среды разработки Beremiz, необходимая для передачи
исполняемого файла на целевое устройство и его отладки, находится в
сценарии на языке Python в файле Beremiz\_service.py. Запуск данного
файла осуществляется из командной строки, следующей командой с
параметрами по умолчанию (см. таблицу 13):

\$ python Beremiz\_service.py

Также, при запуске могут быть указаны параметры, представленные в
таблице 13.

Таблица 13 - Параметры командной строки запуска серверной части среды
Beremiz

\noindent\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Параметр
\unskip}\relax &\textsf{\relax 
Операция
\unskip}\relax \\
\hline
-i
&
Указание IP адреса для обращения клиента,
по умолчанию 127.0.0.1 (localhost)
\\
\hline
-p
&
Номер порта, по умолчанию 3000
\\
\hline
-h
&
Вывод в консоль справки по работе с данным сервером
\\
\hline
-a
&
Автоматический запуск целевого устройства (0 – выключить, 1 – включить),
по умолчанию 0.
\\
\hline
-x
&
Включить/выключить иконку в панели задач (0 – выключить,1 – включить),
по умолчанию 0.
\\
\hline
-t
&
Web-интерфейс на базе библиотеки Twisted (0 – выключить, 1 – включить),
по умолчанию 0.
Он позволяет отслеживать состояние выполнения программы через браузер.
Адрес: http://\textless{}ip-адрес целевого устройства\textgreater{}:\textless{}8009\textgreater{}.
8009 – порт по умолчанию.
\\
\hline\end{tabulary}


После указания всех параметров команды запуска серверной части Beremiz
можно ввести адрес директории, в которой будут храниться файлы на
файловой системе целевого устройства. По умолчанию этой директорией
является временная папка, созданная для текущего запущенного экземпляра
службы Beremiz\_service.

Как правило, данный сценарий запускается в автоматическом режиме при
включении целевого устройства, средствами операционной системы.

Соединение с целевым устройством и передача исполняемого файла

После того как скрипт серверной части среды разработки Beremiz запущен,
можно производить соединение с целевым устройством. В панели настроек
проекта необходимо указать URI-адрес целевого устройства:

PYRO://\textless{}IP-адрес\textgreater{}:\textless{}номер порт\textgreater{}

На \hyperref[usage_guide/work_with_project:image210]{Рисунок \ref{usage_guide/work_with_project:image210} } показан URI адрес целевого устройства LOCAL://,это адрес
Soft PLC на локальной машине, и выделена красным цветом кнопка
«Покдлючиться к целевому ПЛК» (см. таблицу 2), которая используется для
соединения с целевым устройством.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.56977in,height=5.20008in]{{image210}.png}
\caption{- Соединение с целевым устройством}\label{usage_guide/work_with_project:image210}\end{figure}

В случае успешного соединения, в отладочной консоли будет выведено
соответствующее сообщение и выведен статус прикладной программы.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.16883in,height=1.73122in]{{image2111}.png}
\caption{- Отладочная консоль после соединения с целевым устройством}\label{usage_guide/work_with_project:image211}\end{figure}

Статусы прикладной программы могут быть следующие:
\begin{itemize}
\item {} 
«PLC Empty» – прикладная программа отсутствует;

\item {} 
«PLC Started» – прикладная программа на целевом устройстве есть и она
выполняется;

\item {} 
«PLC Stopped» – прикладная программа на целевом устройстве есть, но
остановлена.

\end{itemize}

Используя кнопки передачи, запуска и остановки прикладной программы на
целевом устройстве (см. таблицу 2) можно передать исполняемый файл
прикладной программы, запустить его и остановить. В отладочной консоли
будут выведены соответствующие сообщения (после передачи, запуска и
остановки прикладной программы), как показано на \hyperref[usage_guide/work_with_project:image212]{Рисунок \ref{usage_guide/work_with_project:image212} }:
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=6.80786in,height=3.87209in]{{image212}.png}
\caption{- Отладочная консоль после передачи прикладной программы, запуска и остановки}\label{usage_guide/work_with_project:image212}\end{figure}


\subsubsection{Отладка прикладной программы}
\label{usage_guide/work_with_project:id17}
После установки соединения с целевым устройством и запуском прикладной
программы на выполнение, среда разработки Beremiz позволяет отслеживать
и изменять значения переменных программных модулей, из которых состоит
проект.


\paragraph{Retain переменные в прикладной программе}
\label{usage_guide/work_with_project:retain}
В SoftPLC реализована поддержка переменных, для которых в прикладной
программе определено свойство реманентности (Retain-переменные). При
подключении к серверной части среды разработки Beremiz, создается
временная папка для хранения прикладной программы, загружаемой в
SoftPLC, Retain переменные хранятся в этой временной папке в виде
бинарного файла, содержащего в себе хеш-сумму проекта, значения Retain
переменных в бинарном формате, и контрольную сумму файла, вычисляемую по
алгоритму CRC32.


\paragraph{Запуск отладчика}
\label{usage_guide/work_with_project:id18}
Осуществив передачу скомпилированной программы на SoftPLC, запустите
отладку, нажав кнопку «Запустить ПЛК» (см. табл. 2).
Переменные принимают исходные значения, затем
начинается исполнение программы в ПЛК. Отладчик запущен.


\paragraph{Отладка текстовых языков}
\label{usage_guide/work_with_project:id19}
Работа с отладчиком подразумевает работу с экземпляром загруженной в ПЛК
программы. Функциональные блоки, функции и переменные тоже имеют свои
экземпляры, доступные для отладки только после того как программа будет
запущена на исполнение. В левом нижнем углу основного окна среды
разработки расположена панель экземпляров проекта.
В адресной строке написан адрес ресурса, для которого ниже отображены
экземпляры программ, глобальных переменных и функциональных блоков
определенных в данном ресурсе.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.66539in,height=3.96512in]{{image214}.png}
\caption{- Панель экземпляров проекта}\label{usage_guide/work_with_project:image214}\end{figure}

Переход к родительскому экземпляру и его глобальным переменным
осуществляется кнопкой «Родительский экземпляр»(см. табл. 11).

Кнопка «Отладка экземпляра» (см. табл. 11) напротив адресной строки в
верхней части панели запустит отладку выбранного ресурса(программы или
функционального блока). Для того чтобы включить отладку экземпляра блока
или переменной, нажмите кнопку напротив этого элемента на панели. На
панели отладки отобразятся текущие значения добавленных переменных.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.3704in,height=2.70903in]{{image215}.png}
\caption{- Панель отладчика}\label{usage_guide/work_with_project:image215}\end{figure}

После того как переменная выведена на панель отладки, для того чтобы
установить значение нажмите кнопку «Форсировать значение».
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.40625in,height=2.75in]{{image216}.png}
\caption{- Форсирование переменной в панели отладки}\label{usage_guide/work_with_project:image216}\end{figure}

В появившемся диалоге введите значение переменной (см. \hyperref[usage_guide/work_with_project:image217]{Рисунок \ref{usage_guide/work_with_project:image217} }). Для
булевых переменных в диалоге присутствует кнопка «Переключить значение»,
которая меняет значение переменной на противоположное. После изменения
значения переменной, она будет выделена синим цветом в таблице
переменных и их значений во вкладке «Отладчик».
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.46875in,height=1.82292in]{{image217}.png}
\caption{- Диалог установки значения}\label{usage_guide/work_with_project:image217}\end{figure}

Форсируя значение переменной, вы устанавливаете неизменяемое значение,
переопределение которого выполняемой программой будет невозможно. После
установки значения, его можно освободить, дав возможность программе
изменять значение переменной. Для освобождения переменной нажмите кнопку
«Освободить значение».
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.1706in,height=2.37209in]{{image218}.png}
\caption{- Освобождение значения переменной}\label{usage_guide/work_with_project:image218}\end{figure}

Для корректного изменения, вводимое значение должно соответствовать типу
переменной, иначе будет выведено сообщение об ошибке, как показано
на \hyperref[usage_guide/work_with_project:image219]{Рисунок \ref{usage_guide/work_with_project:image219} }:
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4.26042in,height=1.61458in]{{image219}.png}
\caption{- Ошибка при вводе недопустимого значения изменяемой переменной в режиме отладки}\label{usage_guide/work_with_project:image219}\end{figure}


\paragraph{Отладка графических языков}
\label{usage_guide/work_with_project:id20}
Во время отладки прикладной программы, в которой часть программных
модулей написаны на графических языках, есть возможность видеть
изменения всех значений на диаграмме и вносить необходимые изменения
прямо на ней. Как уже упоминалось ранее, в случае нажатия
кнопки запуска режима отладки (на \hyperref[usage_guide/work_with_project:image220]{Рисунок \ref{usage_guide/work_with_project:image220} } выделены красным цветом) для
экземпляра программы, написанной на одном из графических языков,
откроется вкладка с панелью диаграммы в режиме отладки.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=2.51163in,height=3.73638in]{{image220}.png}
\caption{- Панель экземпляров проекта}\label{usage_guide/work_with_project:image220}\end{figure}

Эти вкладки полностью повторяют те, в которых графические диаграммы
программ или функциональных блоков редактируются, за исключением того
что во вкладках отладчика невозможно внести какие-либо изменения, а
связи между элементами выделяются разным цветом в зависимости от
значения переменной, передаваемого по этой связи.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.70857in,height=3.47361in]{{image221}.png}
\caption{- Пример отлаживаемой FBD диаграммы}\label{usage_guide/work_with_project:image221}\end{figure}

Линии, не выделенные цветом передают либо булевое значение False, либо
переменную не булевого типа (INT, DINT, WORD, REAL, TIME, и т.д.).
Оранжевого цвета связи, передающие константное выражение. Светло-зелёным
цветом выделены связи, которые передают булевое значение True. Связи,
выделенные светло-голубым и тёмно-синим цветом передают значения
непосредственно установленные пользователем, значение
True соответствует светло-голубому цвету, False - тёмно-синему.

\textbf{Отладка FBD диаграммы}

В режиме отладки FBD диаграммы есть возможность устанавливать входные и
выходные значения переменных (с помощью всплывающего меню, которые
вызывается нажатием правой клавишей по соединению) для функциональных
блоков, а также в целом видеть все остальные значения на входах и
выходах элементов диаграммы.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.80233in,height=2.88211in]{{image222}.png}
\caption{- Отладка FBD диаграммы}\label{usage_guide/work_with_project:image222}\end{figure}

Изменённые значения в режиме отладки выделяются синим цветом. После
выбора во всплывающем меню «Освободить значение» значение возвращается в
то, которое получается в результате выполнения логики и алгоритма
данного модуля на данном участке, а соединение на диаграмме становятся
исходного цвета.

\textbf{Отладка LD диаграммы}

Отладка LD диаграммы осуществляется аналогично отладке FBD диаграммы.
Для вызова всплывающего меню (см. рис. 196), в котором можно установить
желаемое значение для контакта или катушки необходимо нажать правую
клавишу мыши.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.23329in,height=2.38763in]{{image223}.png}
\caption{- Пример отладки LD диаграммы}\label{usage_guide/work_with_project:image223}\end{figure}

Появится диалог (см. \hyperref[usage_guide/work_with_project:image224]{Рисунок \ref{usage_guide/work_with_project:image224} }), в котором нужно ввести значение типа
BOOL: TRUE–контакт «ON», FALSE – контакт «OFF».
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.30233in,height=2.02464in]{{image224}.png}
\caption{- Диалог переключения состояния контакта}\label{usage_guide/work_with_project:image224}\end{figure}

\textbf{Отладка SFC диаграммы}

Отладка SFC диаграммы происходит аналогично отладке диаграмм FBD и LD. С
помощью всплывающего меню (см. \hyperref[usage_guide/work_with_project:image225]{Рисунок \ref{usage_guide/work_with_project:image225} }), есть возможность устанавливать
активность для шагов и переходов.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.76744in,height=3.26981in]{{image225}.png}
\caption{- Пример отладки SFC диаграммы}\label{usage_guide/work_with_project:image225}\end{figure}

На \hyperref[usage_guide/work_with_project:image226]{Рисунок \ref{usage_guide/work_with_project:image226} } показано, как устанавливается значение (после выбора
«Форсировать значение», появится диалог) TRUE для шага «ResetCounter».
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.80225in,height=3.28954in]{{image226}.png}
\caption{- Изменение состояния шага ``ResetCounter''}\label{usage_guide/work_with_project:image226}\end{figure}

После установки значения шага в TRUE с помощью режима отладки, шаг будет
выделен голубым цветом. Как можно заметить по \hyperref[usage_guide/work_with_project:image227]{Рисунок \ref{usage_guide/work_with_project:image227} }, т.к. шаг
«ResetCounter» стал активным, блок действий, ассоциированный с ним, так
же стал активным (выделен зелёным цветом), а действия внутри него, в
данном случае присвоение переменной «Cnt» значения конфигурационной
переменной «ResetCounterValue», а переменной «Out» значения переменной
«Cnt»:

Cnt := ResetCounterValue;

Out := Cnt;

стало выполняться.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.95349in,height=3.34762in]{{image227}.png}
\caption{- Форсирование блока действия}\label{usage_guide/work_with_project:image227}\end{figure}

Так как квалификатор этого действия – N, то оно будет выполняться до тех
пор, пока шаг активен.

График изменения значений переменной

Среда разработки Beremiz так же позволяет отображать в виде графика
изменение значения переменной в режиме отладки. Для вывода панели с
графиком, необходимо два раза кликнуть левой кнопкой мыши по кнопке
«Отладка экземпляра» напротив переменной в панели экземпляров проекта.

Появившееся панель графика изменения переменной позволяет
отслеживать то, как значение определённой переменной изменяется в
течение времени.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5.03602in,height=5.43023in]{{image228}.png}
\caption{- График изменения переменных}\label{usage_guide/work_with_project:image228}\end{figure}

На данной панели можно установить интервал обновления и масштаб
отображения графика, а так же передвигать позицию графика.


\subsection{Описание библиотеки функций и функциональных блоков}
\label{usage_guide/library::doc}\label{usage_guide/library:id1}
Функции и функциональные блоки представляют собой предопределённые
элементы, которые могут быть использованы при написании алгоритмов и
логики программных модулей типа «Функциональный блок» и «Программа», как
на текстовых, так и на графических языках стандарта IEC 61131-3.

Данные элементы имеют параметры на входе и на выходе. Как правило,
каждый параметр имеет имя и своё назначение.


\subsubsection{Стандартные функциональные блоки}
\label{usage_guide/library:id2}
\textbf{Бистабильный SR-триггер}

Данный функциональный блок представляет собой бистабильный SR-триггер, с
доминирующим входом S (Set). Выход Q1 становится ``1'', когда вход S1
становится ``1''. Это состояние сохраняется, даже если S1 возвращается
обратно в ``0''. Выход Q1 возвращается в ``0'', когда вход R становится ``1''.
Если входы S1 и R находятся в ``1'' одновременно, доминирующий вход S1
установит выход Q1 в ``1''. Когда функциональный блок вызывается первый
раз, начальное состояние Q1 это ``0''.

\textbf{Бистабильный RS-триггер}

Данный функциональный блок представляет собой бистабильный RS-триггер, с
доминирующим входом R (Reset). Выход Q1 становится ``1'', когда вход S
становится ``1''. Это состояние сохраняется, даже если S возвращается
обратно в ``0''. Выход Q1 возвращается в ``0'', когда вход R1 становится
``1''. Если входы S и R1 находятся в ``1'' одновременно, доминирующий вход
R1 установит выход Q1 в ``0''. Когда функциональный блок вызывается первый
раз, начальное состояние Q1 это ``0''.

\textbf{SEMA - Семафор}

Данный функциональный блок представляет собой семафор, определяющий
механизм, позволяющий элементам программы иметь взаимоисключающий доступ
к определенным ресурсам.

\textbf{R\_TRIG - Индикатор нарастания фронта}

Данный функциональный блок представляет собой индикатор нарастания
фронта, который генерирует на выходе одиночный импульс при нарастании
фронта сигнала. Выход Q становится ``1'', если происходит переход из ``0'' в
``1'' на входе CLK . Выход остается в состоянии ``1'' от одного выполнения
блока до следующего (один цикл); затем выход возвращается в ``0''.

\textbf{F\_TRIG - Индикатор спада фронта}

Данный функциональный блок представляет собой индикатор спада фронта,
который генерирует на выходе одиночный импульс при спаде фронта сигнала.

Выход Q становится ``1'', если происходит переход из ``1'' в ``0'' на входе
CLK . Выход будет оставаться в состоянии ``1'' от одного выполнения блока
до следующего; затем выход возвращается в ``0''.

\textbf{CTU - инкрементный счётчик}

Данный функциональный блок представляет собой инкрементный счётчик.
Сигнал ``1'' на входе R вызывает присваивание значения ``0'' выходу CV . При
каждом переходе из ``0'' в ``1'' на входе CU значение CV увеличивается на 1.
Когда CV \textgreater{}= PV, выход Q устанавливается в ``1''.

Примечание: Счетчик работает только до достижения максимального значения
используемого типа данных. Переполнения не происходит.

Входы CU, RESET и выход Q типа BOOL, вход PV и выход CV типа WORD.

По каждому фронту на входе CU (переход из FALSE в TRUE) выход CV
увеличивается на 1. Выход Q устанавливается в TRUE, когда счетчик
достигнет значения заданного PV. Счетчик CV сбрасывается в 0 по входу
RESET = TRUE.

\textbf{CTD - декрементный счётчик}

Данный функциональный блок представляет собой декрементный счётчик.
Сигнал ``1'' на входе LD вызывает присваивание значения на входе PV выходу
CV . При каждом переходе из ``0'' в ``1'' на входе CD значение CV
уменьшается на 1.

Когда CV \textless{}= 0, выход Q принимает значение ``1''.

Примечание: Счетчик работает только до достижения минимального значения

используемого типа данных. Переполнения не происходит.

\textbf{CTUD - реверсивный счётчик}

Данный функциональный блок представляет собой реверсивный счётчик.
Сигнал ``1'' на входе R вызывает присваивание значения ``0'' выходу CV .
Сигнал ``1'' на входе LD вызывает присваивание значения на входе PV выходу
CV . При каждом переходе из ``0'' в ``1'' на входе CU значение CV
увеличивается на 1. При каждом переходе из ``0'' в ``1'' на входе CD
значение CV уменьшается на 1.

Если сигнал ``1'' приходит одновременно на входы R и LD, вход R
обрабатывается первым.

Когда CV \textgreater{}= PV, выход QU имеет значение ``1''.

Когда CV \textless{}= 0, выход QD принимает значение ``1''.

Примечание: Вычитающий счетчик работает только до достижения
минимального значения используемого типа данных, суммирующий счетчик
работает только до достижения максимального значения используемого типа
данных. Переполнения не происходит.

\textbf{TP - повторитель импульсов}

Данный функциональный блок представляет собой повторитель импульсов и
используется для генерирования импульса с заданной продолжительностью.
Если IN становится ``1'', Q становится ``1'', и начинается отсчет
внутреннего времени (ET). Если внутреннее время достигает значения PT, Q
становится ``0'' (независимо от IN). Отсчет внутреннего времени
останавливается/сбрасывается, если IN становится ``0''. Если внутреннее
время не достигло значения PT, импульс IN не влияет на внутреннее время.
Если внутреннее время достигло значения PT, и IN равен ``0'', отсчет
внутреннего времени останавливается/сбрасывается, и Q становится ``0''.

\textbf{TON - таймер с задержкой включения}

Данный функциональный блок представляет собой таймер с задержкой
включения. Он запускается, когда состояние сигнала на входе меняется от
0 к 1 и устанавливает на выходе 1 по истечении заданного времени.

Если IN становится ``1'', запускается отсчет внутреннего времени (ET).
Если внутреннее время достигает значения PT, Q становится ``1''. Если IN
становится ``0'', Q становится ``0'', а подсчет внутреннего времени
останавливается/сбрасывается. Если IN становится ``0'' до того, как
внутреннее время достигло значения PT, подсчет внутреннего времени
останавливается/сбрасывается, а выход Q не устанавливается в ``0''.

\textbf{TOF - таймер с задержкой отключения}

Данный функциональный блок представляет собой таймер с задержкой
отключения. Он запускается, когда состояние сигнала на входе меняется от
1 к 0 и устанавливает на выходе 0 по истечении заданного времени.

Если IN становится ``1'', Q становится ``1''.

Если IN становится ``0'', запускается отсчет внутреннего времени (ET).

Если внутреннее время достигает значения PT, Q становится ``0''.

Если IN становится ``1'', Q становится ``1'', а подсчет внутреннего времени
останавливается/сбрасывается.

Если IN становится ``1'' до того, как внутреннее время достигло значения
PT, подсчет внутреннего времени останавливается/сбрасывается, а выход Q
не устанавливается в ``0''.


\subsubsection{Дополнительные функциональные блоки}
\label{usage_guide/library:id3}
\textbf{RTC - часы реального времени}

Данный функциональный блок представляет собой часы реального времени и
имеет много вариантов использования, включая добавление временных
отметок, для установки даты и времени в формируемых отчетах, в аварийных
сообщениях и т.д.

Вход PDT (Preset DT) предназначен для установки времени. Часы начинают
отсчет времени от значения PDT. Выход Q (BOOL) повторят значение EN.
Выход CDT (Current DT) дает текущее значение даты и времени.

\textbf{INTEGRAL - Интеграл}

Функциональный блок интеграл интегрирует входное значение XIN по
времени.

\textbf{DERIVATIVE - Производная}

Функциональный блок производная выдаёт значение XOUT пропорционально
скорости изменения входного параметра XIN.

\textbf{PID - Пропорционально-интегрально-дифференциальный регулятор}

Данный функциональный блок представляет собой устройство в цепи обратной
связи, используемое в системах автоматического управления для
формирования управляющего сигнала. ПИД-регулятор формирует управляющий
сигнал, являющийся суммой трёх слагаемых, первое из которых
пропорционально входному сигналу, второе - интеграл входного сигнала,
третье - производная входного сигнала.

\textbf{HYSTERESIS - гистерезис}

Функциональный блок гистерезис предоставляет выходное гистерезисное
булевское значение, которое определяется разницей вводных параметров
XIN1 и XIN2 (типа REAL с плавающей точкой).


\subsubsection{Числовые операции}
\label{usage_guide/library:id4}
\textbf{ABS - модуль числа}

Данная функция возвращает в OUT модуль входного числа IN.

\textbf{SQRT - квадратный корень}

Данная функция возвращает в OUT квадратный корень входного числа IN.

\textbf{LN - натуральный логарифм}

Данная функция возвращает в OUT значение натурального логарифма от IN.

\textbf{LOG - логарифм по основанию 10}

Данная функция возвращает в OUT значение логарифма по основанию 10 от
IN.

\textbf{EXP - возведение в степень экспоненты}

Данная функция возвращает в OUT значение экспоненты, возведённой в
степень IN.

\textbf{SIN - синус}

Данная функция возвращает в OUT значение синуса IN.

\textbf{COS - косинус}

Данная функция возвращает в OUT значение косинуса IN.

\textbf{TAN - тангенс}

Данная функция возвращает в OUT значение тангенса IN.

\textbf{ASIN - арксинус}

Данный функциональный блок возвращает в OUT значение арксинуса IN.

\textbf{ACOS - арккосинус}

Данная функция возвращает в OUT значение арккосинуса IN.

\textbf{ATAN - арктангенс}

Данная функция возвращает в OUT значение арктангенса IN.

Арифметические операции

\textbf{ADD - сложение}

Данная функция возвращает в OUT результат сложения IN1 и IN2.

\textbf{MUL - умножение}

Данная функция возвращает в OUT результат умножения IN1 и IN2.

\textbf{SUB - вычитание}

Данная функция возвращает в OUT результат вычитания из IN1 значения IN2.

\textbf{DIV - деление}

Данная функция возвращает в OUT результат деления IN1 на IN2.

\textbf{MOD - остаток от деления}

Данная функция возвращает в OUT остаток от деления IN1 на IN2.

\textbf{EXPT - возведение в степень}

Данная функция возвращает в OUT значение IN1 возведённое в степень IN2.

\textbf{MOVE - присвоение}

Данная функция возвращает в OUT значение IN.


\subsubsection{Временные операции}
\label{usage_guide/library:id5}
\textbf{ADD\_TIME - сложение переменных типа TIME}

Данная функция складывает входные значения IN(k) типа TIME и возвращает
результат в OUT типа TIME. Количество входов IN(n) изменяемое - от 2 до
20. По умолчанию 2.

\textbf{ADD\_TOD\_TIME - сложение времени дня TOD с интервалом времени TIME}

Данная функция складывает входную переменную IN1 типа TOD (TIME\_OF\_DAY)
с переменной IN2 типа TIME. Возвращаемая величина OUT имеет тип
TIME\_OF\_DAY.

\textbf{ADD\_DT\_TIME - прибавление промежутка времени TIME к моменту времени DT}

Данная функция ADD\_DT\_TIME прибавляет промежуток времени (формат TIME) к
моменту времени (формат DT) и поставляет в качестве результата новый
момент времени (формат DT). Момент времени (параметр T) должен лежать в
диапазоне от DT\#1990-01-01-00:00:00.000 до DT\#2089-12-31-23:59:59.999.

Функция не выполняет входной проверки. Если результат сложения не лежит
внутри допустимого диапазона, то результат ограничивается
соответствующим значением и бит двоичного результата (BR) слова
состояния устанавливается в ``0''.

Для входного параметра Т и выходного параметра можно ставить в
соответствие только символически определенную переменную.

\textbf{MULTIME - умножение времени TIME на число}

Данная функция выполняет умножение входного значения IN1 типа TIME на
число IN2 типа ANY\_NUM и возвращает результат в OUT типа TIME.

\textbf{SUB\_TIME - разность двух значений типа TIME}

Данная функция вычитает из входного значения IN1 типа TIME значение на
входе IN2 типа TIME и возвращает результат в OUT типа TIME.

\textbf{SUB\_DATE\_DATE - разность двух значений типа DATE}

Данная функция вычитает из входного значения IN1 типа DATE входное
значение IN2 типа DATE и возвращает в OUT их разницу типа TIME.

\textbf{SUB\_TOD\_TIME - вычитание из времени дня TOD интервала времени TIME}

Данная функция вычитает из входного значения IN1 типа TOD (TIME\_OF\_DAY)
входное значение IN2 типа TIME и возвращает результат в OUT типа
TIME\_OF\_DAY.

\textbf{SUB\_DT\_TIME - вычитание из момента времени DT промежутка времени TIME}

Данная функция вычитает промежуток времени (формат TIME) из момента
времени (формат DT) и поставляет в качестве результата новый момент
времени (формат DT). Момент времени (параметр T) должен лежать в
диапазоне от DT\#1990-01-01-00:00:00.000 до DT\#2089-12- 31-23:59:59.999.
Функция не выполняет входной проверки. Если результат вычитания не лежит
внутри допустимого диапазона, то результат ограничивается
соответствующим значением и бит двоичного результата (BR) слова
состояния устанавливается в ``0''.

Для входного параметра Т и выходного параметра можно ставить в
соответствие только символически определенную переменную.

\textbf{DIVTIME - деление времени TIME на число}

Данная функция выполняет деление входного значения IN1 типа TIME на
число IN2 типа ANY\_NUM и возвращает результат в OUT типа TIME.

Операции смещения бит

\textbf{SHL - арифметический сдвиг влево}

Данная функция возвращает в OUT арифметический сдвиг аргумента IN на N
бит влево с заполнением битов справа нулями.

\textbf{SHR - арифметический сдвиг вправо}

Данная функция возвращает в OUT арифметический сдвиг аргумента IN на N
бит вправо с заполнением битов слева нулями.

\textbf{ROR - циклический сдвиг направо}

Данная функция возвращает в OUT циклический сдвиг аргумента IN на N бит
влево.

\textbf{ROL - циклический сдвиг влево}

Данная функция возвращает в OUT циклический сдвиг аргумента IN на N бит
вправо.


\subsubsection{Побитовые операции}
\label{usage_guide/library:id6}
\textbf{AND - побитовое И}

Данный функциональный блок представляет собой организацию «логического
И» для всех входных аргументов IN$_{\text{1}}$…IN$_{\text{n}}$.

\textbf{OR - побитовое ИЛИ}

Данная функция представляет собой организацию «логического ИЛИ» для всех
входных аргументов IN$_{\text{1}}$…IN$_{\text{n}}$.

\textbf{XOR - побитовое исключающее ИЛИ}

Данная функция представляет собой организацию «логического исключающего
ИЛИ» для всех входных аргументов IN$_{\text{1}}$…IN$_{\text{n}}$.

\textbf{NOT - побитовая инверсия}

Данная функция представляет собой организацию «логической инверсии» для
входного аргумента IN.

Операции выбора

\textbf{SEL - выбор из двух значений}

Данная функция возвращает в OUT один из двух аргументов IN1 или IN2 в
зависимости от значения аргумента G. Если G = 0, то OUT равно Х1, иначе
- OUT равно X2.

\textbf{MAX - максимум}

Данная функция возвращает в OUT максимум из входных аргументов IN1 и
IN2.

\textbf{MIN - минимум}

Данная функция возвращает в OUT минимум из входных аргументов IN1 и IN2.

\textbf{LIMIT - ограничитель значения}

Данная функция возвращает в OUT значение входного аргумента IN, в случае
превышения им значения MX - в OUT возвращается MX, в случае если IN
меньше MN - в OUT возвращается MN.

\textbf{MUX - Мультиплексор (выбор 1 из N)}

Данная функция возвращает в OUT значение на входе IN(K), в зависимости
от входного K. Количество входов IN:sub:\sphinxtitleref{(n)} изменяемое - от 2 до 20. По
умолчанию 2.


\subsubsection{Операции сравнения}
\label{usage_guide/library:id7}
\textbf{GT - больше чем}

Данная функция сравнивает все входные аргументы и выдаёт на выходе OUT
значение True, если выполнится следующее условие: (IN1 \textgreater{} IN2) \& (IN2 \textgreater{}
IN3) \& ... (IN$_{\text{n-1}}$ \textgreater{} IN$_{\text{n}}$), в противном случае в OUT
выдаётся False. Количество входов IN$_{\text{(n)}}$ изменяемое - от 2 до
20. По умолчанию 2.

\textbf{GE - больше чем или равно}

Данная функция сравнивает все входные аргументы и выдаёт на выходе OUT
значение True, если выполнится следующее условие: (IN1 \textgreater{}= IN2) \& (IN2 \textgreater{}=
IN3) \& ... (IN$_{\text{n-1}}$ \textgreater{}= IN$_{\text{n}}$), в противном случае в OUT
выдаётся False. Количество входов IN$_{\text{(n)}}$ изменяемое - от 2 до
20. По умолчанию 2.

\textbf{EQ - равенство}

Данная функция сравнивает все входные аргументы и выдаёт на выходе OUT
значение True, если выполнится следующее условие: (IN1 = IN2) \& (IN2 =
IN3) \& ... (IN$_{\text{n-1}}$ = IN$_{\text{n}}$), в противном случае в OUT
выдаётся False. Количество входов IN$_{\text{(n)}}$ изменяемое - от 2 до
20. По умолчанию 2.

\textbf{LT - меньше чем}

Данная функция сравнивает все входные аргументы и выдаёт на выходе OUT
значение True, если выполнится следующее условие: (IN1 \textless{} IN2) \& (IN2 \textless{}
IN3) \& ... (IN$_{\text{n-1}}$ \textless{} IN$_{\text{n}}$), в противном случае в OUT выдаётся
False. Количество входов IN$_{\text{(n)}}$ изменяемое - от 2 до 20. По
умолчанию 2.

\textbf{LE - меньше чем или равно}

Данная функция сравнивает все входные аргументы и выдаёт на выходе OUT
значение True, если выполнится следующее условие: (IN1 \textless{}= IN2) \& (IN2 \textless{}=
IN3) \& ... (IN$_{\text{n-1}}$ \textless{}= IN$_{\text{n}}$), в противном случае в OUT выдаётся
False. Количество входов IN$_{\text{(n)}}$ изменяемое - от 2 до 20. По
умолчанию 2.

\textbf{NE - не равно}

Данная функция сравнивает все входные аргументы и выдаёт на выходе OUT
значение True, если выполнится следующее условие: (IN1 \textless{}\textgreater{} IN2) \& (IN2 \textless{}\textgreater{}
IN3) \& ... (IN$_{\text{n-1}}$ \textless{}\textgreater{} IN$_{\text{n}}$), в противном случае в OUT
выдаётся False. Количество входов IN$_{\text{(n)}}$ изменяемое - от 2 до 20. По
умолчанию 2.


\subsubsection{Строковые операции с переменными типа STRING}
\label{usage_guide/library:string}
\textbf{LEN - длина строки}

Данная функция возвращает в OUT длину строки IN. Входному параметру
можно ставить в соответствие только символически определенную
переменную.

\textbf{LEFT - левая часть строки}

Данная функция возвращает в OUT из строки IN первые L символов. Если L
больше, чем текущая длина переменной типа STRING, то возвращается
входное значение. При L = 0 и при пустой строке в качестве входного
значения возвращается пустая строка. Если число L отрицательно, то
выводится пустая строка. Параметру IN и возвращаемому значению можно
ставить в соответствие только символически определенную переменную.

\textbf{RIGHT - правая часть строки}

Данная функция возвращает в OUT из строки IN последние L символов. Если
L больше, чем текущая длина переменной STRING, то возвращается входное
значение. При L = 0 и при пустой строке в качестве входного значения
возвращается пустая строка. Если число L отрицательно, то выводится
пустая строка. Параметру IN и возвращаемому значению можно ставить в
соответствие только символически определенную переменную.

\textbf{MID - середина строки}

Данная функция возвращает в OUT из строки IN L-символов, начиная с
позиции P. Если сумма L и (P-1) превосходит текущую длину переменной
типа STRING, то возвращается строка символов, начиная с P-го символа
входной строки до ее конца. Во всех остальных случаях (P находится вне
текущей длины, P и/или L равны нулю или отрицательны) выводится пустая
строка. Параметру IN и возвращаемому значению можно ставить в
соответствие только символически определенную переменную.

\textbf{CONCAT - объединение двух переменных STRING}

Данная функция возвращает в OUT объединение (конкатенацию) строк IN1 и
IN2.

\textbf{CONCAT\_DAT\_TOD - объединение (конкатенация) времени}

Данная функция возвращает в OUT типа DT конкатенацию входных значений
типов DATE и TOD, соответственно IN1 и IN2.

\textbf{INSERT - вставка в переменной STRING}

Данная функция возвращает в OUT строку IN1, в которую вставлена строка
IN2, начиная с позиции P. Если P равно нулю, то вторая строка символов
вставляется перед первой строкой символов. Если P больше, чем текущая
длина первой строки символов, то вторая строка символов присоединяется к
первой. Если P отрицательно, то выводится пустая строка. Входным
параметрам IN1 и IN2 и выходному параметру можно ставить в соответствие
только символически определенную переменную.

\textbf{DELETE - удаление в переменной STRING}

Данная функция возвращает в OUT строку IN1, в которой удалено L
символов, начиная с позиции P. Если L и/или P равны нулю или P больше,
чем текущая длина входной строки, то возвращается входная строка. Если
сумма L и P больше, чем входная строка символов, то строка символов
удаляется до конца. Если L и/или P имеют отрицательное значение, то
выводится пустая. Входному параметру IN и выходному параметру можно
ставить в соответствие только символически определенную переменную.

\textbf{REPLACE - замена в переменной STRING}

Данная функция возвращает в OUT строку IN1, в которой символы, начиная с
позиции P, заменены L первыми символами строки IN2. Если L равно нулю,
то возвращается первая строка символов. Если P равно нулю или единице,
то замена происходит, начиная с 1-го символа (включительно). Если P
лежит вне первой строки символов, то вторая строка присоединяется к
первой строке. Если L и/или P отрицательны, то возвращается пустая
строка. Входным параметрам IN1 и IN2 и выходному параметру можно ставить
в соответствие только символически определенную переменную.

\textbf{FIND - поиск в переменной STRING}

Данная функция возвращает в OUT номер позиции, в которой находится
строка IN2 в строке IN1. Поиск начинается слева, сообщается о первом
появлении строки символов. Если вторая строка символов не содержится в
первой, то возвращается нуль. Входным параметрам IN1 и IN2 можно ставить
в соответствие только символически определенную переменную.


\section{Языки стандарта МЭК 61131-3}
\label{iec_guide/index::doc}\label{iec_guide/index:id1}
МЭК 61131-3 - раздел международного стандарта МЭК 61131, описывающий языки программирования для программируемых логических контроллеров.


\subsection{Общие сведения о языке ST}
\label{iec_guide/st_guide::doc}\label{iec_guide/st_guide:st}
\begin{sphinxShadowBox}
\textbf{Содержание}

\medskip

\begin{itemize}
\item {} 
\phantomsection\label{iec_guide/st_guide:id8}{\hyperref[iec_guide/st_guide:st]{\sphinxcrossref{Общие сведения о языке ST}}}
\begin{itemize}
\item {} 
\phantomsection\label{iec_guide/st_guide:id9}{\hyperref[iec_guide/st_guide:id2]{\sphinxcrossref{Типы данных}}}

\item {} 
\phantomsection\label{iec_guide/st_guide:id10}{\hyperref[iec_guide/st_guide:id3]{\sphinxcrossref{Конструкции языка}}}

\item {} 
\phantomsection\label{iec_guide/st_guide:id11}{\hyperref[iec_guide/st_guide:id4]{\sphinxcrossref{Арифметические операции}}}
\begin{itemize}
\item {} 
\phantomsection\label{iec_guide/st_guide:id12}{\hyperref[iec_guide/st_guide:id5]{\sphinxcrossref{Логические (побитовые) операции}}}

\item {} 
\phantomsection\label{iec_guide/st_guide:id13}{\hyperref[iec_guide/st_guide:id6]{\sphinxcrossref{Операции сравнения}}}

\item {} 
\phantomsection\label{iec_guide/st_guide:id14}{\hyperref[iec_guide/st_guide:id7]{\sphinxcrossref{Присвоение}}}

\item {} 
\phantomsection\label{iec_guide/st_guide:id15}{\hyperref[iec_guide/st_guide:for]{\sphinxcrossref{Цикл FOR}}}

\item {} 
\phantomsection\label{iec_guide/st_guide:id16}{\hyperref[iec_guide/st_guide:while]{\sphinxcrossref{Цикл WHILE}}}

\item {} 
\phantomsection\label{iec_guide/st_guide:id17}{\hyperref[iec_guide/st_guide:repeat\string-until]{\sphinxcrossref{Цикл REPEAT UNTIL}}}

\item {} 
\phantomsection\label{iec_guide/st_guide:id18}{\hyperref[iec_guide/st_guide:case]{\sphinxcrossref{Конструкция CASE}}}

\end{itemize}

\end{itemize}

\end{itemize}
\end{sphinxShadowBox}

\textbf{ST (Structured Text)} – это текстовый язык высокого уровня общего
назначения, по синтаксису схожий с языком Pascal. Удобен для программ,
включающих числовой анализ или сложные алгоритмы. Может использоваться в
программах, в теле функции или функционального блока, а также для
описания действия и перехода внутри элементов SFC. Согласно IEC 61131-3
ключевые слова должны быть введены в символах верхнего регистра. Пробелы
и метки табуляции не влияют на синтаксис, они могут использоваться
везде.

Выражения в ST выглядят точно также, как и в языке Pascal:

{[}variable{]} := {[}value{]};

Порядок их выполнения – справа налево. Выражения состоят из операндов и
операторов. Операндом является литерал, переменная, структурированная
переменная, компонент структурированной переменной, обращение к функции
или прямой адрес.


\subsubsection{Типы данных}
\label{iec_guide/st_guide:id2}
Согласно стандарту IEC 61131-3, язык ST поддерживает весь необходимый
набор типов, аналогичный классическим языкам программирования.
Целочисленные типы: SINT (char), USINT (unsigned char), INT (short int),
UINT (unsigned int), DINT (long), UDINT (unsigned long), LINT (64 бит
целое), ULINT (64 бит целое без знака). Действительные типы: REAL
(float), LREAL (double). Специальные типы BYTE, WORD, DWORD, LWORD
представляют собой битовые строки длиной 8, 16, 32 и 64 бит
соответственно. Битовых полей в ST нет. К битовым строкам можно
непосредственно обращаться побитно. Например:

a.3 := 1; (* Установить бит 3 переменной a *)

Логический тип BOOL может иметь значение TRUE или FALSE. Физически
переменная типа BOOL может соответствовать одному биту. Строка STRING
является именно строкой, а не массивом. Есть возможность сравнивать и
копировать строки стандартными операторами. Например:

strA := strB;

Для работы со строками есть стандартный набор функций (см. приложение 2,
раздел «Строковые операции с переменными типа STRING»).

Специальные типы в стандарте IEC определены для длительности (TIME),
времени суток (TOD), календарной даты (DATE) и момента времени (DT).

В таблице 3.1 приведены значения по умолчанию, соответствующие описанным
выше типам.

Таблица 3.1 – Значения по умолчанию для типов данных IEC 61131-3

\noindent\begin{tabulary}{\linewidth}{|L|L|}
\hline

Тип(ы) данных
&
Значение
\\
\hline
BOOL, SINT, INT, DINT, LINT
&
0
\\
\hline
USINT, UINT, UDINT, ULINT
&
0
\\
\hline
BYTE, WORD, DWORD, LWORD
&
0
\\
\hline
REAL, LREAL
&
0.0
\\
\hline
TIME
&
T\#0S
\\
\hline
DATE
&
D\#0001-01-01
\\
\hline
TIME\_OF\_DAY
&
TOD\#00:00:00
\\
\hline
DATE\_AND\_TIME
&
DT\#0001-01-01-00:00:00
\\
\hline
STRING
&
‘’ (пустая строка)
\\
\hline\end{tabulary}


По умолчанию, все переменные инициализируются нулем. Иное значение
переменной можно указать явно при ее объявлении. Например:

str1: STRING := ‘Hello world’;

В определённых ситуациях при разработке программных модулей удобно
использовать обобщения типов, т.е. общее именование группы типов данных.
Данные обобщения приведены в таблице 3.2.

Таблица 3.2 – Обобщения типов данных IEC 61131-3

\noindent\begin{tabular}{|p{0.237\linewidth}|p{0.237\linewidth}|p{0.237\linewidth}|p{0.237\linewidth}|}
\hline

ANY
&\multicolumn{3}{l|}{\relax \unskip}\relax \\
\hline
ANY\_BIT
&
ANY\_NUM
&
ANY\_DATE
&
TIME

STRING

и другие типы данных
\\
\hline
BOOL

BYTE

WORD

DWORD

LWORD
&
ANY\_INT
&
ANY\_REAL
&
DATE

TIME\_OF\_DAY

DATE\_AND\_TIME
\\
\hline&
INT

SINT

DINT

LINT
&
UINT

USINT

UDINT

ULINT
&
REAL

LREAL
\\
\hline\end{tabular}



\subsubsection{Конструкции языка}
\label{iec_guide/st_guide:id3}
К конструкциям языка ST относятся:
\begin{itemize}
\item {} 
арифметические операции;

\item {} 
логические (побитовые) операции;

\item {} 
операции сравнения;

\item {} 
операция присвоения;

\item {} 
конструкция IF – ELSEIF – ELSE;

\item {} 
цикл FOR;

\item {} 
цикл WHILE;

\item {} 
цикл REPAET UNTIL;

\item {} 
конструкция CASE.

\end{itemize}

При записи арифметических выражений допустимо использование скобок для
указания порядка вычислений. При записи выражений допустимо использовать
переменные (локальные и глобальные) и константы.


\subsubsection{Арифметические операции}
\label{iec_guide/st_guide:id4}
К арифметическим операциям относятся:
\begin{itemize}
\item {} 
«+» – сложение;

\item {} 
«-» – вычитание;

\item {} 
«*» – умножение;

\item {} 
«/» – деление;

\item {} 
«mod» – остаток от целочисленного деления.

\end{itemize}

Приоритет операций в выражениях указан в таблице 3.4 (чем выше
приоритет, тем раньше исполняется операция).


\paragraph{Логические (побитовые) операции}
\label{iec_guide/st_guide:id5}
К данным операциям относятся:
\begin{itemize}
\item {} 
«OR» – Логическое (побитовое) сложение;

\item {} 
«AND» – Логическое (побитовое) умножение;

\item {} 
«XOR» – Логическое (побитовое) «исключающее ИЛИ»;

\item {} 
«NOT» – Логическое (побитовое) отрицание.

\end{itemize}


\paragraph{Операции сравнения}
\label{iec_guide/st_guide:id6}
Поддерживаются следующие операции сравнения:
\begin{itemize}
\item {} 
«=» – сравнение на равенство;

\item {} 
«\textless{}\textgreater{}» – сравнение на неравенство;

\item {} 
«\textgreater{}» – сравнение на больше;

\item {} 
«\textgreater{}=» – сравнение на не меньше;

\item {} 
«\textless{}» – сравнение на меньше;

\item {} 
«\textless{}=» – сравнение на не больше.

\end{itemize}

В качестве результата сравнения всегда используется значение типа BOOL.


\paragraph{Присвоение}
\label{iec_guide/st_guide:id7}
Для обозначения присвоения используется парный знак «:=». В правой и
левой части выражения должны быть операнды одного типа (автоматического
приведения типов не предусмотрено). В левой части выражения (принимающая
сторона) может быть использована только переменная. Правая часть может
содержать выражение или константу.

В таблице 3.4 приведены приоритеты при выполнении описанных выше
операций.

Таблица 3.4 – Приоритеты операций

\noindent\begin{tabulary}{\linewidth}{|L|L|}
\hline

Операция
&
Приоритет
\\
\hline
Сравнения
&
1
\\
\hline
Сложение, вычитание
&
2
\\
\hline
Умножение, деление
&
3
\\
\hline
OR
&
4
\\
\hline
AND, XOR
&
5
\\
\hline
NOT
&
6
\\
\hline
Унарный минус
&
7
\\
\hline
Вызов функции
&
8
\\
\hline\end{tabulary}


Конструкция IF – ELSEIF – ELSE

Для описания некоторых конструкций языка удобно использовать фигурные и
квадратные скобки. Считается, что:
\begin{itemize}
\item {} 
выражение в фигурных скобках может использоваться ноль или больше раз
подряд;

\item {} 
выражение в квадратных скобках не обязательно к использованию.

\end{itemize}

Конструкция IF-ELSEIF-ELSE имеет следующий формат:

IF \textless{}boolean expression\textgreater{} THEN \textless{}statement list\textgreater{}

{[}ELSEIF \textless{}boolean expression\textgreater{} THEN \textless{}statement list\textgreater{}{]}

{[}ELSE \textless{}statement list\textgreater{}{]}

END\_IF;

Например:

IF Var \textless{}\textgreater{} 0

THEN Var := 1

ELSEIF Var \textgreater{} 0

THEN Var := 0;

ELSE Var := 10;

END\_IF;

Конструкция допускает вложенность, т.е. внутри одного IF может быть еще
один и т.д. Например:

IF Var \textgreater{} 10 THEN

IF Var \textless{} Var2 + 1

THEN Var := 10;

ELSE Var := 0;

END\_IF;

END\_IF;


\paragraph{Цикл FOR}
\label{iec_guide/st_guide:for}
Служит для задания цикла с фиксированным количеством итераций. Формат
конструкции следующий:

FOR \textless{}Control Variable\textgreater{} := \textless{}expression1\textgreater{} TO \textless{}expression2\textgreater{}

{[}BY \textless{}expression3\textgreater{}{]} DO

\textless{}statement list\textgreater{}

END\_FOR;

При задании условий цикла считается, что \textless{}Control Variable\textgreater{},
\textless{}expression1\textgreater{} … \textless{}expression3\textgreater{} имеют тип INT. Выход из цикла будет
произведен в том случае, если значение переменной цикла превысит
значение \textless{}expression2\textgreater{}. Например:

FOR i := 1 TO 10 BY 2 DO

k := k * 2;

END\_FOR;

Оператор BY задает приращение переменной цикла (в данном случае i будет
увеличиваться на 2 при каждом проходе по циклу). Если оператор BY не
указан, то приращение равно 1. Например:

FOR i := 1 TO k / 2 DO

var := var + k;

k := k – 1;

END\_FOR;

Внутри цикла могут использоваться другие циклы, операторы IF и CASE. Для
выхода из цикла (любого типа) может использоваться оператор EXIT.
Например:

FOR i := 1 TO 10 BY 2 DO

k := k * 2;

IF k \textgreater{} 20 THEN

EXIT;

END\_IF;

END\_FOR;

Примечание 1: Выражения \textless{}expression1\textgreater{} … \textless{}expression3\textgreater{} вычисляются до
входа в цикл, поэтому изменения значений переменных, входящих в любое из
этих выражений не приведет к изменению числа итераций. Например:

01: k := 10;

02: FOR I := 1 TO k / 2 DO

03: k := 20;

04: END\_FOR;

В строке 3 производится изменение переменной k, но цикл все равно
выполнится только пять раз. Примечание 2: Значение переменной цикла
может изменяться внутри тела цикла, но в начале очередной итерации
значение данной переменной будет выставлено в соответствие с условиями
цикла. Например:

01: FOR I := 1 TO 5 DO

02: I := 55;

03: END\_FOR;

При первом проходе значение I будет равно 1, потом в строке 2 изменится
на 55, но на втором проходе значение I станет равно 2 – следующему
значению по условиям цикла.


\paragraph{Цикл WHILE}
\label{iec_guide/st_guide:while}
Служит для определения цикла с предусловием. Цикл будет исполняться до
тех пор, пока выражение в предложении WHILE возвращает TRUE. Формат
конструкции следующий:

WHILE \textless{}Boolean-Expression\textgreater{} DO

\textless{}Statement List\textgreater{}

END\_WHILE;

Значение \textless{}Boolean-Expression\textgreater{} проверяется на каждой итерации. Завершение
цикла произойдет, если выражение \textless{}Boolean-Expression\textgreater{} вернет FALSE.
Например:

k := 10;

WHILE k \textgreater{} 0 DO

i := I + k;

k := k –1;

END\_WHILE;

Внутри цикла могут использоваться другие циклы, операторы IF и CASE. Для
досрочного завершения цикла используется оператор EXIT (см. пример в
описание цикла FOR).


\paragraph{Цикл REPEAT UNTIL}
\label{iec_guide/st_guide:repeat-until}
Служит для определения цикла с постусловием. Завершение цикла произойдет
тогда, когда выражение в предложении UNTIL вернет FALSE. Другими
словами: цикл будет выполняться, пока условие в предложении UNTIL не
выполнятся. Формат конструкции следующий:

REPEAT

\textless{}Statement List\textgreater{}

UNTIL \textless{}Boolean Expression\textgreater{};

END\_REPEAT;

Например:

k := 10;

REPEAT

i := i + k;

k := k – 1;

UNTIL k = 0;

END\_REPEAT;

Внутри цикла могут использоваться другие циклы, операторы IF и CASE. Для
досрочного завершения цикла используется оператор EXIT (см. пример в
описании цикла FOR).


\paragraph{Конструкция CASE}
\label{iec_guide/st_guide:case}
Данная конструкция служит для организации выбора из диапазона значений.
Формат конструкции следующий:

CASE \textless{}Expression\textgreater{} OF

CASE\_ELEMENT \{CASE\_ELEMENT\}

{[}ELSE \textless{}Statement List\textgreater{}{]}

END\_CASE;

CASE\_ELEMENT – это список значений, перечисленных через запятую.
Элементом списка может быть целое число или диапазон целых чисел.
Диапазон задается следующим образом BEGIN\_VAL .. END\_VAL.

Если текущее значение \textless{}Expression\textgreater{} не попало ни в один CASE\_ELEMENT, то
управление будет передано на предложение ELSE. Если предложение ELSE не
указано, то никаких действий выполнено не будет.

Значение \textless{}Expression\textgreater{} может быть только целым. Например:

01: CASE k OF

02: 1:

03: k := k * 10;

04: 2..5:

05: k := k * 5;

06: i := 0;

07: 6, 9..20:

08: k := k – 1;

09: ELSE

10: k := 0;

11: i := 1;

12: END\_CASE;

Строка 4 содержит диапазон значений. Если значение k принадлежит
числовому отрезку {[}2, 5{]}, то будут выполнены строки 5 и 6.

В строке 7 использован список значений. Строка 8 выполнится, если
значение k будет равно 6 или будет принадлежать числовому отрезку {[}9,
20{]}.

Строки 10 и 11 будут выполнены в том случае, если k \textless{} 1, или 6 \textless{} k \textless{} 9,
или k \textgreater{} 20 (в данном случае сработает предложение ELSE).

При задании списка значений необходимо выполнять следующие условия:
\begin{itemize}
\item {} 
наборы значений внутри одного CASE не должны пересекаться;

\item {} 
при указании диапазона значений начало диапазона должно быть меньше
его конца.

\end{itemize}

В таблице 3.5 приведены примеры кода записи правильной и неправильной
записи конструкции CASE.

Действия, предусмотренные для обработки каждого из случаев CASE, могут
использовать циклы, операторы IF и CASE.

Таблица 3.5 – Запись конструкции CASE

\noindent\begin{tabular}{|p{0.475\linewidth}|p{0.475\linewidth}|}
\hline

Неправильная запись
&
Правильная запись
\\
\hline
01: CASE k OF

02: 1:

03: k := k * 10;

04: 2..5:

05: k := k * 5;

06: i := 0;

07: 5, 9..20:

08: k := k – 1;

09: ELSE

10: k := 0;

11: i := 1;

12: END\_CASE;

Диапазоны в строках 4 и 7 пересекаются
&
01: CASE k OF

02: 1:

03: k := k * 10;

04: 2..5:

05: k := k * 5;

06: i := 0;

07: 6, 9..20:

08: k := k – 1;

09: ELSE

10: k := 0;

11: i := 1;

12: END\_CASE;
\\
\hline
01: CASE k OF

02: 1:

03: k := k * 10;

04: 2..5:

05: k := k * 5;

06: i := 0;

07: 6, 20..9:

08: k := k – 1;

09: ELSE

10: k := 0;

11: i := 1;

12: END\_CASE;

В строке 7 диапазон значений задан неправильно.
&
01: CASE k OF

02: 1:

03: k := k * 10;

04: 2..5:

05: k := k * 5;

06: i := 0;

07: 6, 9..20:

08: k := k – 1;

09: ELSE

10: k := 0;

11: i := 1;

12: END\_CASE;
\\
\hline\end{tabular}


При написании программ на ST возможно использование стандартных и
пользовательских функций и функциональных блоков.


\subsection{Общие сведения о языке IL}
\label{iec_guide/il_guide::doc}\label{iec_guide/il_guide:il}
\begin{sphinxShadowBox}
\textbf{Содержание}

\medskip

\begin{itemize}
\item {} 
\phantomsection\label{iec_guide/il_guide:id4}{\hyperref[iec_guide/il_guide:il]{\sphinxcrossref{Общие сведения о языке IL}}}
\begin{itemize}
\item {} 
\phantomsection\label{iec_guide/il_guide:id5}{\hyperref[iec_guide/il_guide:id2]{\sphinxcrossref{Операторы языка}}}

\item {} 
\phantomsection\label{iec_guide/il_guide:id6}{\hyperref[iec_guide/il_guide:id3]{\sphinxcrossref{Пример программы на языке IL}}}

\end{itemize}

\end{itemize}
\end{sphinxShadowBox}

\textbf{IL (Instruction List)} представляет собой текстовый язык программирования
низкого уровня, который очень похож на Assembler, но к конкретной
архитектуре процессора не привязан. Он позволяет описывать функции,
функциональные блоки и программы, а также шаги и переходы в языке SFC.
Одним из ключевых преимуществ IL является его простота и возможность
добиться оптимизированного кода для реализации критических секторов
программ. Особенности IL делают его неудобным для описания сложных
алгоритмов с большим количеством разветвлений.


\subsubsection{Операторы языка}
\label{iec_guide/il_guide:id2}
Основа языка программирования IL, как и в случае Assembler, это переходы
по меткам и аккумулятор. В аккумулятор загружается значения переменной,
а дальнейшее выполнение алгоритма представляет собой извлечение значения
из аккумулятора и совершение над ним операций. Далее в таблице 4.1
приведены операторы языка IL.

Таблица 1 – Операторы языка IL

\begin{longtable}{|l|l|}
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\tablecontinued{\tablename\ \thetable{} -- продолжение с предыдущей страницы}}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{\tablecontinued{Продолжается на следующей странице}}} \\ \hline
\endfoot

\endlastfoot


Оператор
&
Описание
\\
\hline
LD
&
Загрузить значение операнда в аккумулятор
\\
\hline
LDN
&
Загрузить обратное значение операнда в аккумулятор
\\
\hline
ST
&
Присвоить значение аккумулятора операнду
\\
\hline
STN
&
Присвоить обратное значение аккумулятора операнду
\\
\hline
S
&
Если значение аккумулятора TRUE, установить логический операнд
\\
\hline
R
&
Если значение аккумулятора FALSE, сбросить логический операнд
\\
\hline
AND
&
Поразрядное И аккумулятора и операнда
\\
\hline
ANDN
&
Поразрядное И аккумулятора и обратного операнда
\\
\hline
OR
&
Поразрядное ИЛИ аккумулятора и операнда
\\
\hline
ORN
&
Поразрядное ИЛИ аккумулятора и обратного операнда
\\
\hline
XOR
&
Поразрядное разделительное ИЛИ аккумулятора и операнда
\\
\hline
XORN
&
Поразрядное разделительное ИЛИ аккумулятора и обратного операнда
\\
\hline
NOT
&
Поразрядная инверсия аккумулятора
\\
\hline
ADD
&
Сложение аккумулятора и операнда, результат записывается в аккумулятор
\\
\hline
SUB
&
Вычитание операнда из аккумулятора, результат записывается в аккумулятор
\\
\hline
MUL
&
Умножение аккумулятора на операнд, результат записывается в аккумулятор
\\
\hline
DIV
&
Деление аккумулятора на операнд, результат записывается в аккумулятор
\\
\hline
GT
&
Значение аккумулятора сравнивается со значением операнда(\textgreater{}(greater than)). Значение (TRUE или FALSE) записывается в аккумулятор
\\
\hline
GE
&
Значение аккумулятора сравнивается со значением операнда(\textgreater{}=greater than or equal)). Значение (TRUE или FALSE) записывается в аккумулятор
\\
\hline
EQ
&
Значение аккумулятора сравнивается со значением операнда (=(equal)). Значение (TRUE или FALSE) записывается в аккумулятор
\\
\hline
NE
&
Значение аккумулятора сравнивается со значением операнда (\textless{}\textgreater{}(not equal). Значение (TRUE или FALSE) записывается в аккумулятор
\\
\hline
LE
&
Значение аккумулятора сравнивается со значением операнда (\textless{}=(less than or equal to)). Значение (TRUE или FALSE) записывается в аккумулятор
\\
\hline
LT
&
Значение аккумулятора сравнивается со значением операнда (\textless{}(less than)). Значение (TRUE или FALSE) записывается в аккумулятор
\\
\hline
JMP
&
Переход к метке
\\
\hline
JMPC
&
Переход к метке при условии, что значение аккумулятора TRUE
\\
\hline
JMPCN
&
Переход к метке при условии, что значение аккумулятора FALSE
\\
\hline
CAL
&
Вызов программного или функционального блока
\\
\hline
CALC
&
Вызов программного или функционального блока при условии, что значение аккумулятора TRUE
\\
\hline
CALCN
&
Вызов программного или функционального блока при условии, что значение аккумулятора FALSE
\\
\hline
RET
&
Выход из POU и возврат в вызывающую программу
\\
\hline
RETC
&
Выход из POU и возврат в вызывающую программу при условии, что значение аккумулятора TRUE
\\
\hline
RETCN
&
Выход из POU и возврат в вызывающую программу при условии, что значение аккумулятора FALSE
\\
\hline\end{longtable}



\subsubsection{Пример программы на языке IL}
\label{iec_guide/il_guide:id3}
На рис. 1 приведён пример программы на языке IL, которая эквивалентна
следующему логическому выражению C = A AND NOT B:

\sphinxincludegraphics[width=3.07986in,height=1.76250in]{{image11}.png}

Рис. 1 – Пример программы на языке IL

Первый оператор примера LD помещает значение переменной A в аккумулятор,
способный хранить значения любого типа. Второй оператор ANDN выполняет
«побитовое И» аккумулятора и обратного значения операнда, результат
всегда помещается в аккумулятор. Последний оператор примера ST
присваивает переменной C значение аккумулятора.


\subsection{Общие сведения о языке LD}
\label{iec_guide/ld_guide:ld}\label{iec_guide/ld_guide::doc}
\begin{sphinxShadowBox}
\textbf{Содержание}

\medskip

\begin{itemize}
\item {} 
\phantomsection\label{iec_guide/ld_guide:id2}{\hyperref[iec_guide/ld_guide:ld]{\sphinxcrossref{Общие сведения о языке LD}}}

\end{itemize}
\end{sphinxShadowBox}

\textbf{LD (Ladder Diagram)} – графический язык, основанный на принципах
релейно-контактных схем (элементами релейно-контактной логики являются:
контакты, обмотки реле, вертикальные и горизонтальные перемычки и др.) с
возможностью использования большого количества различных функциональных
блоков. Достоинствами языка LD являются: представление программы в виде
электрического потока (близко специалистам по электротехнике), наличие
простых правил, использование только булевых выражений. На рис. 6.1
приведён пример программы на языке LD (слева) и ее эквивалент в виде
электрической цепи с реле и выключателями (справа).

\sphinxincludegraphics[width=6.13472in,height=2.24097in]{{image340}.jpeg}

Рис. 6.1 – Программа на языке LD (слева) и ее эквивалент в виде
электрической (справа)

Схемы, реализованные на данном языке, называются многоступенчатыми. Они
представляют собой набор горизонтальных цепей, напоминающих ступеньки
лестницы, соединяющих вертикальные шины питания.

Объекты языка программирования LD обеспечивают средства для
структурирования программного модуля в некоторое количество контактов,
катушек. Эти объекты взаимосвязаны через фактические параметры или
связи.

Порядок обработки индивидуальных объектов в LD-секции определяется
потоком данных внутри секции. Ступени, подключенные к левой шине
питания, обрабатываются сверху вниз (соединение к левой шине питания).
Ступени внутри секции, которые не зависят друг от друга, обрабатываются
в порядке размещения.

Основные конструкции языка

Слева и справа схема на языке LD ограничена вертикальными линиями –
шинами питания. Между ними расположены цепи, образованные контактами и
катушками реле, по аналогии с обычными электронными цепями. Слева любая
цепь начинается набором контактов, которые посылают слева направо
состояние «ON» или «OFF», соответствующие логическим значениям TRUE или
FALSE. Каждому контакту соответствует логическая переменная (типа BOOL).
Если переменная имеет значение TRUE, то состояние передается через
контакт. Иначе – правое соединение получает значение выключено (``OFF'').

Контакты могут быть соединены параллельно, тогда соединение передает
состояние «логическое ИЛИ». Если контакты соединены последовательно, то
соединение передаёт «логическое И».

Контакт может быть инвертируемым. Такой контакт обозначается с помощью
символа \textbar{}/\textbar{} и передает состояние ``ON'', если значение переменной FALSE.

Язык LD позволяет:
\begin{itemize}
\item {} 
выполнять последовательное соединение контактов;

\item {} 
выполнять параллельное соединение контактов;

\item {} 
применять нормально разомкнутые или замкнутые контакты;

\item {} 
использовать переключаемые контакты;

\item {} 
записывать комментарии;

\item {} 
включать Set/Reset-выходы (Установка/Сброс);

\item {} 
переходы;

\item {} 
включать в диаграмму функциональные блоки;

\item {} 
управлять работой блоков по входам EN.

\end{itemize}

Контакт

Контактом является LD-элемент, который передаёт состояние горизонтальной
связи левой стороны горизонтальной связи на правой стороне. Это
состояние – результат булевой AND-операции состояния горизонтальной
связи с левой стороны с состоянием ассоциированной переменной или
прямого адреса. Контакт не изменяет значения связанной переменой или
прямого адреса.

Для нормальных контактов (см. рис. 6.2) состояние левой связи передается
в правую связь, если состояние связанного логического фактического
параметра TRUE. Иначе, состояние правой связи FALSE.

\sphinxincludegraphics[width=1.32292in,height=0.72917in]{{image341}.png}

Рис. 6.2 – Нормальный контакт

Для инверсных контактов (см. рис. 6.3) состояние левой связи передается
в правую связь, если состояние связанного логического фактического
параметра FALSE. Иначе, состояние правой связи TRUE.

\sphinxincludegraphics[width=1.41667in,height=0.75000in]{{image342}.png}

Рис. 6.3 – Инверсный контакт

В контактах для обнаружения нарастания фронта (см. рис 6.4) правая связь
устанавливается в состояние TRUE, если переход связанного фактического
параметра происходит из FALSE в TRUE, и в то же время состояние левой
связи TRUE. Иначе, состояние правой связи FALSE.

\sphinxincludegraphics[width=1.63542in,height=0.62500in]{{image343}.png}

Рис. 6.4 – Контакт для обнаружения нарастания фронта

В контактах для обнаружения спада фронта (см. рис. 6.5) правая связь
устанавливается в состояние TRUE, если переход связанного фактического
параметра происходит из True в False, и состояние левой связи True в то
же время. Иначе, состояние правой связи FALSE.

\sphinxincludegraphics[width=1.72917in,height=0.75000in]{{image344}.png}

Рис. 6.5 – Контакт для обнаружения спада фронта

Катушка

Катушка является LD-элементом, который передаёт состояние горизонтальной
связи на левой стороне неизменяемым горизонтальной связи на правой
стороне. В этом процессе состояние связанной переменной или прямого
адреса будет сохранено.

В нормальных катушках (см. рис. 6.6) состояние левой связи передается в
связанный логический фактический параметр и в правую связь.

\sphinxincludegraphics[width=1.76042in,height=0.75000in]{{image345}.png}

Рис. 6.6 – Нормальная катушка

В инвертирующей катушке (см. рис. 6.7) состояние левой связи копируется
в правую связь. Инвертированное состояние левой связи копируется в
связанный логический фактический параметр. Если связь находится в
состоянии FALSE, тогда правая связь тоже будет находиться в состоянии
FALSE, и связанный логический фактический параметр будет находиться в
состоянии TRUE.

\sphinxincludegraphics[width=1.70833in,height=0.69792in]{{image346}.png}

Рис. 6.7 – Инвертирующая катушка

В катушке установки (см. рис. 6.8) состояние левой связи копируется в
правую связь. Связанный логический фактический параметр устанавливается
в состояние TRUE, если левая связь имеет состояние TRUE, иначе он не
изменяется. Связанный логический фактический параметр может сбрасываться
только катушкой сброса.

\sphinxincludegraphics[width=1.71875in,height=0.77083in]{{image347}.png}

Рис. 6.8 – Катушка установки

В катушке сброса (см. рис. 6.9) состояние левой связи копируется в
правую связь. Связанный логический фактический параметр устанавливается
в состояние FALSE, если левая связь имеет состояние TRUE, иначе он не
изменяется. Связанный логический фактический параметр может
устанавливаться только катушкой установки.

\sphinxincludegraphics[width=1.63542in,height=0.75000in]{{image348}.png}

Рис. 6.9 – Катушка сброса

В катушке обнаружения нарастания фронта (см. рис. 6.10) состояние левой
связи копируется в правую связь. Связанный фактический параметр типа
данных BOOL будет установлен в состояние TRUE для цикла программы, если
произошел переход левой связи из FALSE в TRUE.

\sphinxincludegraphics[width=1.65625in,height=0.69792in]{{image349}.png}

Рис. 6.10 – Катушка обнаружения нарастания фронта

В катушке обнаружения спада фронта (см. рис. 6.11) состояние левой связи
копируется в правую связь. Связанный фактический параметр типа данных
BOOL будет установлен в состояние TRUE для цикла программы, если
произошел переход левой связи из TRUE в FALSE.

\sphinxincludegraphics[width=1.65625in,height=0.65625in]{{image350}.png}

Рис. 6.11 – Катушка обнаружения спада фронта

Слово «катушка» имеет обобщенный образ исполнительного устройства,
поэтому в русскоязычной документации обычно говорят о выходе цепочки,
хотя можно встретить и частные значения термина, например катушка реле.

Шина питания

Левая шина питания соответствует единичному сигналу. Ступени,
подключённые к левой шине питания, обрабатываются сверху вниз
(соединение к левой шине питания).

Пример программы на языке LD

Пример представляет собой реализацию логического выражения:

C = A AND NOT B

При создании LD диаграмм можно использовать только переменные типа BOOL.
Добавим новый контакт и привяжем его к имени A (имени переменной). Далее
добавляется шина питания слева, шина питания справа, нормальный контакт,
инверсный контакт и нормальная катушка. Нормальный контакт ассоциируется
с переменной A, инверсный контакт с переменой B, нормальная катушка с
переменной C. Далее это всё последовательно соединяется (см. рис. 6.12),
и результатом является программа, написанная на языке LD, реализующая
логическое выражение:

C = A AND NOT B

\sphinxincludegraphics[width=3.10486in,height=0.75000in]{{image351}.png}

Рис. 6.12 – Пример LD диаграммы, реализующей логическое выражение C = A
AND NOT B


\subsection{Общие сведения о языке SFC}
\label{iec_guide/sfc_guide::doc}\label{iec_guide/sfc_guide:sfc}
\begin{sphinxShadowBox}
\textbf{Содержание}

\medskip

\begin{itemize}
\item {} 
\phantomsection\label{iec_guide/sfc_guide:id9}{\hyperref[iec_guide/sfc_guide:sfc]{\sphinxcrossref{Общие сведения о языке SFC}}}
\begin{itemize}
\item {} 
\phantomsection\label{iec_guide/sfc_guide:id10}{\hyperref[iec_guide/sfc_guide:id2]{\sphinxcrossref{Основные понятия языка SFC}}}
\begin{itemize}
\item {} 
\phantomsection\label{iec_guide/sfc_guide:id11}{\hyperref[iec_guide/sfc_guide:id3]{\sphinxcrossref{Шаг}}}

\item {} 
\phantomsection\label{iec_guide/sfc_guide:id12}{\hyperref[iec_guide/sfc_guide:id4]{\sphinxcrossref{Переход}}}

\item {} 
\phantomsection\label{iec_guide/sfc_guide:id13}{\hyperref[iec_guide/sfc_guide:id5]{\sphinxcrossref{Блок действий}}}

\item {} 
\phantomsection\label{iec_guide/sfc_guide:id14}{\hyperref[iec_guide/sfc_guide:id6]{\sphinxcrossref{«Прыжок» – переход на произвольный шаг}}}

\item {} 
\phantomsection\label{iec_guide/sfc_guide:id15}{\hyperref[iec_guide/sfc_guide:id7]{\sphinxcrossref{Дивергенция и конвергенция}}}

\end{itemize}

\item {} 
\phantomsection\label{iec_guide/sfc_guide:id16}{\hyperref[iec_guide/sfc_guide:id8]{\sphinxcrossref{Пример программы на языке SFC}}}

\end{itemize}

\end{itemize}
\end{sphinxShadowBox}

\textbf{SFC (Sequential Function Chart)} расшифровывается как «Последовательность
функциональных диаграмм», и является одним из языков стандарта IEC
61131-3. SFC позволяет легко описывать последовательность протекания
процессов в системе.

SFC осуществляет последовательное управление процессом, базируясь на
системе условий, передающих управления с одной операции на другую. Язык
SFC состоит из конечного числа базовых элементов, которые используются
как блоки для построения целостного алгоритма протекания программы.


\subsubsection{Основные понятия языка SFC}
\label{iec_guide/sfc_guide:id2}
Язык SFC использует следующие структурные элементы для создания
программы: шаг (и начальный шаг), переход, блок действий, прыжок и связи
типа дивергенция и конвергенция.

После вызова программного модуля, описанного языком SFC, первым
выполняется начальный шаг. Шаг, выполняемый в данный момент, называется
активным. Действия, связанные с активным шагом, выполняются один раз в
каждом управляющем цикле. В режиме выполнения активные шаги выделяются
салатовым цветом. Следующий за активным шагом шаг станет активным,
только если в переходе между этими шагами условие будет истинно.

В каждом управляющем цикле будут выполнены действия, содержащиеся в
активных шагах. Далее проверяются условия перехода, и, возможно, уже
другие шаги становятся активными, но выполняться они будут уже в
следующем цикле.

Далее описывается каждый элемент SFC диаграммы.


\paragraph{Шаг}
\label{iec_guide/sfc_guide:id3}
Наиболее важным элементом языка SFC является шаг, который описывает одну
операцию. Шаг изображается в виде прямоугольника с собственным именем
внутри (см. рис. 7.1).

\sphinxincludegraphics[width=1.05139in,height=0.61389in]{{image352}.png}

Рис. 7.1 – Графическое представление «Шага» языка SFC

У каждого шага может быть 3 контакта. Сверху и снизу для соединения с
переходом и справа для соединения с блоком действий. Шаг предваряется
переходом, который определяет условие для активации данного шага в
процессе выполнения программы и отображается в виде горизонтальной черты
на ветви диаграммы процесса с указанием имени и условия. Два шага
никогда не могут быть соединены непосредственно, они должны всегда
отделяться переходом (см. рис. 7.2).

\sphinxincludegraphics[width=1.22500in,height=2.15625in]{{image353}.png}

Рис. 7.2 – Шаги «step2» и «step3», соединённые переходом «tr2\_3»

Любая SFC диаграмма должна содержать начальный шаг (шаг, выделенный
двойной рамкой), с которого начинается выполнение диаграммы.


\paragraph{Переход}
\label{iec_guide/sfc_guide:id4}
Между шагами находятся так называемые переходы. Условием перехода может
быть логическая переменная или константа, логический адрес или
логическое выражение, описанное на любом языке. Условие может включать
серию инструкций, образующих логический результат, в виде ST выражения,
например:

(i\textless{}= 100) AND b

либо на любом другом языке.

На рис. 7.3 приведён пример перехода между шагом «Step3» и «Step5» с
именем «transition4».

\sphinxincludegraphics[width=1.29167in,height=2.33333in]{{image354}.png}

Рис. 7.3 – Переход между шагами «Step3» и «Step5» с предопределённым
условием «transition4»

В данном случае «transition4» это имя для предопределённого перехода,
который может использоваться многократно на SFC диаграмме для
определения переходов между несколькими шагами. Код для него может быть
представлен, например, на языке ST:

:= (flag = True AND level \textgreater{} 10);

На рис. 7.4 представлен переход между шагами «Step6» и «Step7» в виде
обычного условия:

level \textgreater{} 10

\sphinxincludegraphics[width=1.19514in,height=1.98958in]{{image355}.png}

Рис. 7.4 – Переход между шагами «step6» и «step7» с предопределённым
условием «transition4»

На рис. 7.5 представлен переход между шагами «Step8» и «Step9» в виде
значения логического выражения «AND» на языке FBD:

\sphinxincludegraphics[width=1.54306in,height=1.84375in]{{image356}.png}

Рис. 7.5 – Переход между шагами «step8» и «step9», заданный «логическим
И» на языке FBD

Условие не должно содержать присваивания, вызов программ и экземпляров
функциональных блоков.


\paragraph{Блок действий}
\label{iec_guide/sfc_guide:id5}
Каждый шаг имеет нулевое или большее количеством действий, объединённых,
как правило, на диаграмме, в блок действий. На рис. 7.6 показан примера
шага «evaluateStep» и связанный с ним блок действий.

\sphinxincludegraphics[width=3.45347in,height=1.18125in]{{image357}.png}

Рис. 7.6 – Шаг «evaluateStep» и связанный с ним блок действий,
содержащий 3 действия

Блок действий определяет операции, которые должны выполняться при
активации (выполнении) шага. Шаги без связанного блока действий
идентифицируются как ждущий шаг. Блок действий может состоять из
предопределённых действий. Каждому предопределённому действию
присваивается имя (на рис. 7.6 это «action0» и «action1»). Одно действие
может использоваться сразу в нескольких шагах. Действие может
выполняться непрерывно, пока активен шаг, либо единожды. Это
определяется специальными квалификаторами, описание которых приведено в
таблице 6. Квалификаторы также могут ограничивать время выполнения
каждого действия в шаге.


\paragraph{«Прыжок» – переход на произвольный шаг}
\label{iec_guide/sfc_guide:id6}
Шаг может быть также заменён «прыжком». Последовательности шагов всегда
ассоциируются с прыжком к другому шагу той же самой последовательности
шагов. Это означает, что они выполняются циклически. Переход на
произвольный шаг – это соединение на шаг, имя которого указано под
знаком «прыжка». Такие переходы нужны для того, чтобы избежать
пересекающихся и идущих вверх соединений. На рис. 7.7 показана SFC
диаграмма, содержащая два «прыжка».

\sphinxincludegraphics[width=3.36667in,height=3.63403in]{{image358}.png}

Рис. 7.7 – SFC диаграмма, содержащая «прыжки»

Первый делает переход к шагу «init» в случае выполнения условия
«transition4», второй делает переход к шагу «step1», в случае выполнения
условия «transition2».


\paragraph{Дивергенция и конвергенция}
\label{iec_guide/sfc_guide:id7}
Дивергенция – это множественное соединение в направлении от одного шага
к нескольким переходам. Активируется только одна из ветвей. Условия,
связанные с различными переходами в начале дивергенции, не являются
взаимоисключающими по умолчанию. Взаимоисключение должно быть явно
задано в условиях переходов, чтобы гарантировать, что во время
выполнения программы активируется одна конкретная ветвь. Пример
дивергенции на SFC диаграмме приведён на рис. 7.8 и выделен красным
цветом:

\sphinxincludegraphics[width=3.03542in,height=2.70417in]{{image359}.png}

Рис. 7.8 – Дивергенция на SFC диаграмме

Конвергенция – это множественное соединение, направленное от нескольких
переходов к одному и тому же шагу. Она обычно используется для
группировки ветвей SFC – программы, которые берут начало из одинарной
дивергенции. Пример конвергенции на SFC диаграмме приведён на рис. 7.9 и
выделен красным цветом:

\sphinxincludegraphics[width=3.11389in,height=3.24375in]{{image360}.png}

Рис. 7.9 – Конвергенция на SFC диаграмме

Параллельная дивергенция – это множественное соединение, направленное от
одного перехода к нескольким шагам. Она соответствует параллельному
выполнению операций процесса. Пример параллельной дивергенции на SFC
диаграмме приведён на рис. 7.10 и выделен красным цветом:

\sphinxincludegraphics[width=3.08681in,height=2.66944in]{{image361}.png}

Рис. 7.10 – Параллельная дивергенция на SFC диаграмме

Параллельная конвергенция – это соединение нескольких шагов к одному и
тому же переходу. Обычно она используется для группирования ветвей,
взявших начало дивергенции. Пример параллельной конвергенции на SFC
диаграмме приведён на рис. 7.11 и выделен красным цветом:

\sphinxincludegraphics[width=3.07014in,height=3.02153in]{{image362}.png}

Рис. 7.11 – Параллельная конвергенция на SFC диаграмме


\subsubsection{Пример программы на языке SFC}
\label{iec_guide/sfc_guide:id8}
На рис. 7.12 приведен пример SFC диаграммы состоящей из начального шага
«initStep», шагов «firstStep» и «secondStep» и 3 перехода.

Переход «startFlag» представляет обычную переменную типа BOOL и
полностью зависит от её значения. Переход между «firstStep» и
«secondStep» зависит от LD диаграммы с двумя катушками, ассоциированными
с переменными типа BOOL: «in1» и «in2». Переход активируется только в
том случае, если «in1» и «in2» будут TRUE. Переход между «secondStep» и
прыжком на initStep активирован, когда значение переменной «value»
меньше -100.

Во время действия «firstStep» выполняется увеличение переменной count на
1. Во время действия «secondStep» из переменной «value» вычитается 10.

\sphinxincludegraphics[width=5.41389in,height=3.02847in]{{image363}.png}

Рис. 7.12 – SFC диаграмма


\subsection{Общие сведения о языке FBD}
\label{iec_guide/fbd_guide::doc}\label{iec_guide/fbd_guide:fbd}
\begin{sphinxShadowBox}
\textbf{Содержание}

\medskip

\begin{itemize}
\item {} 
\phantomsection\label{iec_guide/fbd_guide:id4}{\hyperref[iec_guide/fbd_guide:fbd]{\sphinxcrossref{Общие сведения о языке FBD}}}
\begin{itemize}
\item {} 
\phantomsection\label{iec_guide/fbd_guide:id5}{\hyperref[iec_guide/fbd_guide:id2]{\sphinxcrossref{Основные понятия и конструкции языка}}}

\item {} 
\phantomsection\label{iec_guide/fbd_guide:id6}{\hyperref[iec_guide/fbd_guide:id3]{\sphinxcrossref{Пример программы на языке FBD}}}

\end{itemize}

\end{itemize}
\end{sphinxShadowBox}

\textbf{FBD (Function Block Diagram)} – это графический язык программирования
высокого уровня, обеспечивающий управление потока данных всех типов.
Позволяет использовать мощные алгоритмы простым вызовом функций и
функциональных блоков. Удовлетворяет непрерывным динамическим процессам.
Замечательно подходит для небольших приложений и удобен для реализации
сложных вещей подобно ПИД регуляторам, массивам и т. д. Данный язык
может использовать большую библиотеку блоков, описание которых приведено
в приложении 2. FBD заимствует символику булевой алгебры и, так как
булевы символы имеют входы и выходы, которые могут быть соединены между
собой, FBD является более эффективным для представления структурной
информации, чем язык релейно-контактных схем.


\subsubsection{Основные понятия и конструкции языка}
\label{iec_guide/fbd_guide:id2}
Согласно IEC 61131­3, основными элементами языка FBD являются:
переменные, функции, функциональные блоки и соединения.

Переменные бывают входные, выходные и входные/выходные. На рис. 1
показаны: входная переменная – «in\_var», выходная переменная –
«out\_var» и входная/выходная переменная – «in\_out\_var».

\sphinxincludegraphics[width=1.14722in,height=1.10764in]{{image1}.png}

Рис. 1 – Изображение переменной в языке FBD

Графическое изображение функции приведено на рис. 2. С левой стороны
располагаются вхо­ды (IN1 и IN2), с правой стороны выходы (OUT).

\sphinxincludegraphics[width=1.13056in,height=0.84028in]{{image2}.png}

Рис. 2 – Изображение функции в языке FBD

Аналогично, изображение функционального блока, приведённое на рис. 3,
имеет с левой стороны вхо­ды (S1 и R), с правой стороны выход (Q1).

\sphinxincludegraphics[width=1.26875in,height=1.05556in]{{image3}.png}

Рис. 3 – Изображение функционального блока в языке FBD

Соответственно, переменные соединяются с входными и выходными
параметрами функций и функциональных блоков. Входные переменные могут
быть соединены только с входными параметрами функции или функционального
блока, выходные переменные – только с выходными параметрами функции или
функционального блока, входные/выходные переменные – как входами, так и
с выходами функции или функционального блока. Также выходной параметр
одной функции или функционального блока может быть напрямую соединён с
входным параметром другого.

\sphinxincludegraphics[width=4.27847in,height=1.11667in]{{image4}.png}

Рис. 4 – Пример соединения переменных, функций и функциональных блоков

Все функциональные блоки могут быть вызваны с дополнительными
(необязатель­ными) формальными параметрами: EN (входом) и ENO (выходом).
Пример такого функционального блока приведен на рис. 5.

\sphinxincludegraphics[width=1.18264in,height=0.95972in]{{image5}.png}

Рис. 5 – Изображение элементарного функционального блока с параметрами
EN/ENO

Если функциональный блок вызывается с параметрами EN/ENO и при этом
значе­ние EN равно нулю, то алгоритмы, определяемые в функциональном
блоке, не будут вы­полняться. В этом случае значение ENO автоматически
устанавлива­ется равным 0. Если же значение EN равно 1, то алгоритмы,
опреде­ляемые функциональным блоком, будут выполнены. После выполнения
этих алгоритмов без ошибок значение ENO автоматически устанавливается
равным 1. Если же возникает ошибка во время выполнения этих алгоритмов,
то значение ENO будет установлено равным 0. Поведение функционального
блока одинаково как в случае вызова функционального блока с EN = 1, так
и при вызове без параметров EN/ENO.

Для более компактного соединения входов и выходов различных функций и
функциональных блоков используются элементы «Соединение», показанные на
рис. 6:

\sphinxincludegraphics[width=1.02500in,height=0.77083in]{{image6}.png}

Рис. 6 – Изображение соединений в языке FBD

Они бывают двух видов: входное соединение и выходное выходные
соединение. Основная задача соединений – передать значение из одного
выхода на другой вход без прямого соединения выхода и входа. На рис. 5.7
показан пример, в котором выходное значение OUT функции BOOL\_TO\_INT
передаётся на вход IN2 функции ADD:

\sphinxincludegraphics[width=2.59097in,height=1.86875in]{{image7}.png}

Рис. 7 – Пример использования соединения на FBD диаграмме


\subsubsection{Пример программы на языке FBD}
\label{iec_guide/fbd_guide:id3}
На рис. 8 приведена FBD диаграмма, состоящая из следующих
функциональных блоков: SR0, AND, TP0.

\sphinxincludegraphics[width=6.73194in,height=1.61736in]{{image8}.png}

Рис. 8 – пример FBD диаграммы

Функциональный блок SR0 представляет собой Бистабильный SR-триггер. У
него имеются входы S1, R1 и выход Q1, а так же дополнительный вход EN и
выход ENO, позволяющие включать и выключать выполнение SR0. Выход Q1 с
помощью соединён с входом IN1 блока AND, представляющий собой
«Логическое И». Вход IN2 типа BOOL соединён с литералом «BOOL\#1»,
который всегда положительный. Выход OUT блока AND соединён с входом IN
функционального блока TP0, представляющий собой повторитель импульсов.
Вход PT типа TIME, соединён с литералом «T\#5s», который задаёт значение
5 секунд.

Если после запуска выполнения данного функционального блока enabled
равно True и переменная S1\_IN тоже True, функциональный блок SR0
начинает выполняться. На выходе OUT функционального блока AND будет
значение True как только Q1 у SR0 будет равен True. Следовательно, как
только OUT становится True вход IN функционального блока TP0 принимает
тоже True и начинается отсчёт таймера ET (см. рис. 9).

\sphinxincludegraphics[width=6.56458in,height=1.59583in]{{image9}.png}

Рис. 9 – Выполнение FBD диаграммы

Пока данный таймер не достигнет значения PT выход Q у функционального
блока TP0 будет равен True. При достижении таймером ET значения PT, т.е.
через 5 секунд выход Q становится False (см. рис. 10).

\sphinxincludegraphics[width=6.62083in,height=1.62569in]{{image10}.png}

Рис. 10 – Выполнение FBD диаграммы

Как только вход IN функционального блока TP0 становится значения FALSE,
счётчик ET сбрасывается в T\#0s.


\section{Beremiz: Руководство разработчика}
\label{developer_guide/index:beremiz}\label{developer_guide/index::doc}

\subsection{Документация softPLC}
\label{developer_guide/soft_plc/index:softplc}\label{developer_guide/soft_plc/index::doc}

\subsubsection{Отладчик}
\label{developer_guide/soft_plc/debugger::doc}\label{developer_guide/soft_plc/debugger:id1}
Debugger code. 

On ``publish'', when buffer is free, debugger stores arbitrary variables content into, and mark this buffer as filled Buffer content is read asynchronously, (from non real time part), and then buffer marked free again. 
\paragraph{Defines}
\index{BUFFER\_FREE (макроподстановка C)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:c.BUFFER_FREE}\pysigline{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a95fea78248a755c58dd4dc1531c85be0}\sphinxbfcode{BUFFER\_FREE}}
\end{fulllineitems}

\index{BUFFER\_BUSY (макроподстановка C)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:c.BUFFER_BUSY}\pysigline{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1ab81aa0aee75b5a5857987840efc19d96}\sphinxbfcode{BUFFER\_BUSY}}
\end{fulllineitems}

\index{\_\_Unpack\_case\_t (макроподстановка C)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:c.__Unpack_case_t}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1ac4a861567e0c77f4d3600877c6a3bf07}\sphinxbfcode{\_\_Unpack\_case\_t}}{TYPENAME}{}
\end{fulllineitems}

\index{\_\_Unpack\_case\_p (макроподстановка C)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:c.__Unpack_case_p}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a2da7a1b17c4e90432c9357ebd8acaa9c}\sphinxbfcode{\_\_Unpack\_case\_p}}{TYPENAME}{}
\end{fulllineitems}

\index{\_\_RegisterDebugVariable\_case\_t (макроподстановка C)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:c.__RegisterDebugVariable_case_t}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a74ac12a75e81d646fee43b330a1c6ee8}\sphinxbfcode{\_\_RegisterDebugVariable\_case\_t}}{TYPENAME}{}
\end{fulllineitems}

\index{\_\_RegisterDebugVariable\_case\_p (макроподстановка C)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:c.__RegisterDebugVariable_case_p}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1ab454aa9d376dbdaba0f5076b3ad9c47e}\sphinxbfcode{\_\_RegisterDebugVariable\_case\_p}}{TYPENAME}{}
\end{fulllineitems}

\index{\_\_ResetDebugVariablesIterator\_case\_t (макроподстановка C)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:c.__ResetDebugVariablesIterator_case_t}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a9bad34b0f76281bc871cc0d470267152}\sphinxbfcode{\_\_ResetDebugVariablesIterator\_case\_t}}{TYPENAME}{}
\end{fulllineitems}

\index{\_\_ResetDebugVariablesIterator\_case\_p (макроподстановка C)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:c.__ResetDebugVariablesIterator_case_p}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1ad75b84baa8f23d6d8aa0b71816ade4be}\sphinxbfcode{\_\_ResetDebugVariablesIterator\_case\_p}}{TYPENAME}{}
\end{fulllineitems}

\paragraph{Typedefs}
\index{\_\_for\_each\_variable\_do\_fp (тип C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv225__for_each_variable_do_fp}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a676fc44b4a3a029d8e24b0c5caf4b67c}\sphinxstrong{typedef }void (*\sphinxbfcode{\_\_for\_each\_variable\_do\_fp})}{{\hyperref[developer_guide/soft_plc/debugger:_CPPv211dbgvardsc_t]{\sphinxcrossref{dbgvardsc\_t}}} *}{}
\end{fulllineitems}

\paragraph{Functions}
\index{\_\_for\_each\_variable\_do (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv222__for_each_variable_do25__for_each_variable_do_fp}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1ad40543d87da75cc90f0b8686b4baf8dc}void \sphinxbfcode{\_\_for\_each\_variable\_do}}{{\hyperref[developer_guide/soft_plc/debugger:_CPPv225__for_each_variable_do_fp]{\sphinxcrossref{\_\_for\_each\_variable\_do\_fp}}} \emph{fp}}{}
\end{fulllineitems}

\index{UnpackVar (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv29UnpackVarP11dbgvardsc_tPPvPc}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1ac777523459e2bfcefb8bfafa12578e6a}void *\sphinxbfcode{UnpackVar}}{{\hyperref[developer_guide/soft_plc/debugger:_CPPv211dbgvardsc_t]{\sphinxcrossref{dbgvardsc\_t}}} *\emph{dsc}, void **\emph{real\_value\_p}, char *\emph{flags}}{}
\end{fulllineitems}

\index{Remind (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv26RemindjjPv}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1aea9cd655ebc20489eca22e0ce880e3fe}void \sphinxbfcode{Remind}}{unsigned int \emph{offset}, unsigned int \emph{count}, void *\emph{p}}{}
\end{fulllineitems}

\index{RemindIterator (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv214RemindIteratorP11dbgvardsc_t}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a25b3b2a0ee28b64464686a83bb71c890}void \sphinxbfcode{RemindIterator}}{{\hyperref[developer_guide/soft_plc/debugger:_CPPv211dbgvardsc_t]{\sphinxcrossref{dbgvardsc\_t}}} *\emph{dsc}}{}
\end{fulllineitems}

\index{CheckRetainBuffer (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv217CheckRetainBufferv}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1adeeb7602f45001228912c24a33564f63}int \sphinxbfcode{CheckRetainBuffer}}{void}{}
\end{fulllineitems}

\index{InitRetain (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv210InitRetainv}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a146a11b5307a7d6cfb709c0f8b50f0b3}void \sphinxbfcode{InitRetain}}{void}{}
\end{fulllineitems}

\index{\_\_init\_debug (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv212__init_debugv}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1aeb464eeaefb94c2159257d418b216958}void \sphinxbfcode{\_\_init\_debug}}{void}{}
\end{fulllineitems}

\index{InitiateDebugTransfer (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv221InitiateDebugTransferv}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a9d1a5b4d6626c0f88d0081820cee1283}void \sphinxbfcode{InitiateDebugTransfer}}{void}{}
\end{fulllineitems}

\index{CleanupRetain (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv213CleanupRetainv}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1aba498c5b81b472ebc42c92e000f79cd1}void \sphinxbfcode{CleanupRetain}}{void}{}
\end{fulllineitems}

\index{\_\_cleanup\_debug (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv215__cleanup_debugv}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1ad2a8f8251f5a001a66c1147a0b57ef5a}void \sphinxbfcode{\_\_cleanup\_debug}}{void}{}
\end{fulllineitems}

\index{\_\_retrieve\_debug (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv216__retrieve_debugv}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a074de87df478c7d0490d23f796d20ffc}void \sphinxbfcode{\_\_retrieve\_debug}}{void}{}
\end{fulllineitems}

\index{Retain (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv26RetainjjPv}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a1735854400b858da6d96197b78745f57}void \sphinxbfcode{Retain}}{unsigned int \emph{offset}, unsigned int \emph{count}, void *\emph{p}}{}
\end{fulllineitems}

\index{BufferIterator (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv214BufferIteratorP11dbgvardsc_ti}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a1d1cdc9e6409e0b110bc0084d5ec8385}\sphinxstrong{static} void \sphinxbfcode{BufferIterator}}{{\hyperref[developer_guide/soft_plc/debugger:_CPPv211dbgvardsc_t]{\sphinxcrossref{dbgvardsc\_t}}} *\emph{dsc}, int \emph{do\_debug}}{}
\end{fulllineitems}

\index{DebugIterator (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv213DebugIteratorP11dbgvardsc_t}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1aca05d148564a2a8a08c2284a1b2aa370}void \sphinxbfcode{DebugIterator}}{{\hyperref[developer_guide/soft_plc/debugger:_CPPv211dbgvardsc_t]{\sphinxcrossref{dbgvardsc\_t}}} *\emph{dsc}}{}
\end{fulllineitems}

\index{RetainIterator (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv214RetainIteratorP11dbgvardsc_t}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a455409f89dd4443d831238a328f8db98}void \sphinxbfcode{RetainIterator}}{{\hyperref[developer_guide/soft_plc/debugger:_CPPv211dbgvardsc_t]{\sphinxcrossref{dbgvardsc\_t}}} *\emph{dsc}}{}
\end{fulllineitems}

\index{PLC\_GetTime (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv211PLC_GetTimeP8IEC_TIME}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a2736eabade03ec59d365126c8424daa5}void \sphinxbfcode{PLC\_GetTime}}{IEC\_TIME *}{}
\end{fulllineitems}

\index{TryEnterDebugSection (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv220TryEnterDebugSectionv}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a4b5c2153b5826cda7283f813dfe44e81}int \sphinxbfcode{TryEnterDebugSection}}{void}{}
\end{fulllineitems}

\index{AtomicCompareExchange (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv221AtomicCompareExchangePlll}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1ac08ed1a6ba408ee94db616120fc03f95}long \sphinxbfcode{AtomicCompareExchange}}{long *, long, long}{}
\end{fulllineitems}

\index{AtomicCompareExchange64 (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv223AtomicCompareExchange64Pxxx}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a780ae8a52a14f8fdfdcdf907b4dc51cc}long long \sphinxbfcode{AtomicCompareExchange64}}{long long *, long long, long long}{}
\end{fulllineitems}

\index{LeaveDebugSection (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv217LeaveDebugSectionv}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a8eaf82dbd3a424df1231c49540cd0000}void \sphinxbfcode{LeaveDebugSection}}{void}{}
\end{fulllineitems}

\index{ValidateRetainBuffer (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv220ValidateRetainBufferv}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a8ff012b8d09fafe99d68ee0a910f0d7f}void \sphinxbfcode{ValidateRetainBuffer}}{void}{}
\end{fulllineitems}

\index{InValidateRetainBuffer (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv222InValidateRetainBufferv}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a0ce89cc3436d2510f5dc82cb446fb639}void \sphinxbfcode{InValidateRetainBuffer}}{void}{}
\end{fulllineitems}

\index{\_\_publish\_debug (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv215__publish_debugv}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a595d415eff968ea28b2f4885584b0436}void \sphinxbfcode{\_\_publish\_debug}}{void}{}
\end{fulllineitems}

\index{RegisterDebugVariable (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv221RegisterDebugVariableiPv}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a5fad9b8e686f89736ac84a6fa5fa536a}void \sphinxbfcode{RegisterDebugVariable}}{int \emph{idx}, void *\emph{force}}{}
\end{fulllineitems}

\index{ResetDebugVariablesIterator (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv227ResetDebugVariablesIteratorP11dbgvardsc_t}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1aaee9f3ef84c233eec630cc187f40154e}void \sphinxbfcode{ResetDebugVariablesIterator}}{{\hyperref[developer_guide/soft_plc/debugger:_CPPv211dbgvardsc_t]{\sphinxcrossref{dbgvardsc\_t}}} *\emph{dsc}}{}
\end{fulllineitems}

\index{ResetDebugVariables (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv219ResetDebugVariablesv}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a62f4226a92546fd7e0fcc29bfbe1e516}void \sphinxbfcode{ResetDebugVariables}}{void}{}
\end{fulllineitems}

\index{FreeDebugData (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv213FreeDebugDatav}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a863a3044dbcb9c228cc1bd227a5c5a38}void \sphinxbfcode{FreeDebugData}}{void}{}
\end{fulllineitems}

\index{WaitDebugData (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv213WaitDebugDataPm}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a4caa6b5dbe0770aef060c0b65dd3ff1d}int \sphinxbfcode{WaitDebugData}}{unsigned long *\emph{tick}}{}
\end{fulllineitems}

\index{GetDebugData (функция C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv212GetDebugDataPmPmPPv}\pysiglinewithargsret{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1ac07fa375c02b2aab116d8f8bb805106e}int \sphinxbfcode{GetDebugData}}{unsigned long *\emph{tick}, unsigned long *\emph{size}, void **\emph{buffer}}{}
\end{fulllineitems}

\paragraph{Variables}
\index{buffer\_state (поле C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv212buffer_state}\pysigline{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1ab5323aa37543b681d86c6ddcf0b279aa}long \sphinxbfcode{buffer\_state}}
\end{fulllineitems}

\index{debug\_buffer (поле C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv212debug_buffer}\pysigline{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a93612ad2a6786b453089420d15971ca7}char \sphinxbfcode{debug\_buffer}{[}BUFFER\_SIZE{]}}
\end{fulllineitems}

\index{buffer\_cursor (поле C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv213buffer_cursor}\pysigline{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a5fadac4feebf48ff29c6a3f6b30aab2c}char *\sphinxbfcode{buffer\_cursor}}
\end{fulllineitems}

\index{retain\_offset (поле C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv213retain_offset}\pysigline{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1ae2065fa52f5faa8a8535c3085304b45c}unsigned int \sphinxbfcode{retain\_offset}}
\end{fulllineitems}

\index{dbgvardsc (поле C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv29dbgvardsc}\pysigline{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1aba8d07200c09c44b0d7e5a439f0d8c23}{\hyperref[developer_guide/soft_plc/debugger:_CPPv211dbgvardsc_t]{\sphinxcrossref{dbgvardsc\_t}}} \sphinxbfcode{dbgvardsc}{[}{]}}
\end{fulllineitems}

\index{\_\_tick (поле C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv26__tick}\pysigline{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsplc__debug_8c_1a8d1c9c4205a71208ccbde1aeedf1aa5a}unsigned long \sphinxbfcode{\_\_tick}}
\end{fulllineitems}

\index{dbgvardsc\_t (класс C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv211dbgvardsc_t}\pysigline{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsstructdbgvardsc__t}\sphinxstrong{struct }\sphinxbfcode{dbgvardsc\_t}}~\paragraph{Public Members}
\index{dbgvardsc\_t::ptr (поле C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv2N11dbgvardsc_t3ptrE}\pysigline{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsstructdbgvardsc__t_1a21dcc7569691fd5b1403212ba6c64f70}void *\sphinxbfcode{ptr}}
\end{fulllineitems}

\index{dbgvardsc\_t::type (поле C++)}

\begin{fulllineitems}
\phantomsection\label{developer_guide/soft_plc/debugger:_CPPv2N11dbgvardsc_t4typeE}\pysigline{\phantomsection\label{developer_guide/soft_plc/debugger:beremiz_targetsstructdbgvardsc__t_1ae389d440dab30b806d7e3c10fc9b06cc}\_\_IEC\_types\_enum \sphinxbfcode{type}}
\end{fulllineitems}


\end{fulllineitems}



\section{Участие в разработке документации}
\label{documentation_guide/index::doc}\label{documentation_guide/index:id1}
Для написании документации на Beremiz используется формат \href{http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html}{restructredText}.


\subsection{Быстрый старт}
\label{documentation_guide/quick_start::doc}\label{documentation_guide/quick_start:id1}\begin{enumerate}
\item {} 
\href{https://docs.docker.com/install/}{Установить Docker}

\item {} 
Загрузить исходники Beremiz:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{clone} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{jubnzv}\PYG{o}{/}\PYG{n}{beremiz} \PYG{n}{beremiz}
\end{Verbatim}

\item {} 
Для сборки документации:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{beremiz}\PYG{o}{/}\PYG{n}{doc}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{Makefile}\PYG{o}{.}\PYG{n}{docker}
\end{Verbatim}

\end{enumerate}

Сгенерированные документы в форматах \sphinxtitleref{pdf} и \sphinxtitleref{html} будут расположны в директории \sphinxtitleref{beremiz/doc/build}.


\subsection{Настройка окружения и сборка документации}
\label{documentation_guide/installation::doc}\label{documentation_guide/installation:id1}

\subsubsection{По умолчанию: Использование Docker}
\label{documentation_guide/installation:docker}
Для упрощения установки на различные платформы предполагается использование \href{https://hub.docker.com/r/jubnzv1/sphinx-build/}{docker-контейнера}, содержащего необходимые для сборки пакеты.
\begin{enumerate}
\item {} 
\href{https://docs.docker.com/install/}{Установить Docker}

\item {} 
Загрузить исходники Beremiz:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{clone} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{jubnzv}\PYG{o}{/}\PYG{n}{beremiz} \PYG{n}{beremiz}
\end{Verbatim}

\item {} 
Для сборки документации:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{beremiz}\PYG{o}{/}\PYG{n}{doc}
\PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{Makefile}\PYG{o}{.}\PYG{n}{docker}
\end{Verbatim}

\end{enumerate}

Сгенерированные документы в форматах \sphinxtitleref{pdf} и \sphinxtitleref{html} будут расположны в директории \sphinxtitleref{beremiz/doc/build}.


\subsubsection{Альтернатива: Нативная установка (Debian GNU/Linux)}
\label{documentation_guide/installation:debian-gnu-linux}
Для Debian Stretch потребуется установить следующие пакеты:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{o}{\PYGZhy{}}\PYG{n}{y} \PYG{n}{install} \PYG{n}{make} \PYGZbs{}
            \PYG{n}{python2}\PYG{o}{.}\PYG{l+m+mi}{7} \PYGZbs{}
            \PYG{n}{python}\PYG{o}{\PYGZhy{}}\PYG{n}{sphinx} \PYGZbs{}
            \PYG{n}{python}\PYG{o}{\PYGZhy{}}\PYG{n}{sphinx}\PYG{o}{\PYGZhy{}}\PYG{n}{rtd}\PYG{o}{\PYGZhy{}}\PYG{n}{theme} \PYGZbs{}
            \PYG{n}{doxygen} \PYGZbs{}
            \PYG{n}{graphviz} \PYGZbs{}
            \PYG{n}{python}\PYG{o}{\PYGZhy{}}\PYG{n}{breathe} \PYGZbs{}
            \PYG{n}{breathe}\PYG{o}{\PYGZhy{}}\PYG{n}{doc} \PYGZbs{}
            \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{base} \PYGZbs{}
            \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{latex}\PYG{o}{\PYGZhy{}}\PYG{n}{base} \PYGZbs{}
            \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{lang}\PYG{o}{\PYGZhy{}}\PYG{n}{cyrillic} \PYGZbs{}
            \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{fonts}\PYG{o}{\PYGZhy{}}\PYG{n}{recommended} \PYGZbs{}
            \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{generic}\PYG{o}{\PYGZhy{}}\PYG{n}{extra} \PYGZbs{}
            \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{latex}\PYG{o}{\PYGZhy{}}\PYG{n}{extra} \PYGZbs{}
            \PYG{n}{texlive}\PYG{o}{\PYGZhy{}}\PYG{n}{latex}\PYG{o}{\PYGZhy{}}\PYG{n}{recommended}
\end{Verbatim}

После этого сборка может быть запущена нативно:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{beremiz}\PYG{o}{/}\PYG{n}{doc}
\PYG{n}{make} \PYG{n}{html} \PYG{n}{latexpdf}
\end{Verbatim}


\subsection{TODO}
\label{documentation_guide/todo_pages:todo}\label{documentation_guide/todo_pages::doc}\begin{itemize}
\item {} 
{[} {]} Текущий раздел:
\begin{itemize}
\item {} 
{[}X{]} Quick start

\item {} 
{[}X{]} Linux installation notes

\item {} 
{[} {]} Краткое введение в rst и инструкции по настройке редакторов (emacs + pycharm)

\item {} 
{[} {]} Документирование кода (C-темплейты из \emph{targets} и Python-код)

\item {} 
{[} {]} Работа с LaTeX и сборка pdf: внесение изменений в генерируемый .tex-код и модификация дефолтных опций форматирования

\end{itemize}

\item {} 
{[} {]} IEC Guide
\begin{itemize}
\item {} 
{[} {]} Актуализировать информацию для текущей версии Beremiz

\end{itemize}

\item {} 
{[} {]} Usage Guide
\begin{itemize}
\item {} 
{[}X{]} Обновить информацию; убрать функционал, относящийся к модулям ИНЭУМ

\item {} 
{[} {]} Разбить документ на отдельные файлы по разделам

\end{itemize}

\item {} 
{[} {]} Install guide
\begin{itemize}
\item {} 
{[} {]} Обновить раздел с Windows 7

\item {} 
{[} {]} Установка на *nix

\item {} 
{[} {]} Инструкции для Windows 10

\end{itemize}

\end{itemize}



\renewcommand{\indexname}{Алфавитный указатель}
\printindex
\end{document}
